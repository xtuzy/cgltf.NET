// Auto generated by yangzhou
// cgltf version: 1.14

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace cgltf.NET;
	public static unsafe partial class cgltf
	{
static sbyte[] const_0 = new sbyte[] { 100, 97, 116, 97, 58, 0};// "data:"
static sbyte[] const_1 = new sbyte[] { 59, 98, 97, 115, 101, 54, 52, 0};// ";base64"
static sbyte[] const_2 = new sbyte[] { 58, 47, 47, 0};// "://"
static sbyte[] const_3 = new sbyte[] { 92, 92, 0};// "\\"
static sbyte[] const_true = new sbyte[] { 116, 114, 117, 101, 0};// "true"
static sbyte[] const_POSITION = new sbyte[] { 80, 79, 83, 73, 84, 73, 79, 78, 0};// "POSITION"
static sbyte[] const_NORMAL = new sbyte[] { 78, 79, 82, 77, 65, 76, 0};// "NORMAL"
static sbyte[] const_TANGENT = new sbyte[] { 84, 65, 78, 71, 69, 78, 84, 0};// "TANGENT"
static sbyte[] const_TEXCOORD = new sbyte[] { 84, 69, 88, 67, 79, 79, 82, 68, 0};// "TEXCOORD"
static sbyte[] const_COLOR = new sbyte[] { 67, 79, 76, 79, 82, 0};// "COLOR"
static sbyte[] const_JOINTS = new sbyte[] { 74, 79, 73, 78, 84, 83, 0};// "JOINTS"
static sbyte[] const_WEIGHTS = new sbyte[] { 87, 69, 73, 71, 72, 84, 83, 0};// "WEIGHTS"
static sbyte[] const_attributes = new sbyte[] { 97, 116, 116, 114, 105, 98, 117, 116, 101, 115, 0};// "attributes"
static sbyte[] const_bufferView = new sbyte[] { 98, 117, 102, 102, 101, 114, 86, 105, 101, 119, 0};// "bufferView"
static sbyte[] const_material = new sbyte[] { 109, 97, 116, 101, 114, 105, 97, 108, 0};// "material"
static sbyte[] const_variants = new sbyte[] { 118, 97, 114, 105, 97, 110, 116, 115, 0};// "variants"
static sbyte[] const_extras = new sbyte[] { 101, 120, 116, 114, 97, 115, 0};// "extras"
static sbyte[] const_mappings = new sbyte[] { 109, 97, 112, 112, 105, 110, 103, 115, 0};// "mappings"
static sbyte[] const_mode = new sbyte[] { 109, 111, 100, 101, 0};// "mode"
static sbyte[] const_indices = new sbyte[] { 105, 110, 100, 105, 99, 101, 115, 0};// "indices"
static sbyte[] const_targets = new sbyte[] { 116, 97, 114, 103, 101, 116, 115, 0};// "targets"
static sbyte[] const_extensions = new sbyte[] { 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 0};// "extensions"
static sbyte[] const_KHR_draco_mesh_compression = new sbyte[] { 75, 72, 82, 95, 100, 114, 97, 99, 111, 95, 109, 101, 115, 104, 95, 99, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 0};// "KHR_draco_mesh_compression"
static sbyte[] const_KHR_materials_variants = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 118, 97, 114, 105, 97, 110, 116, 115, 0};// "KHR_materials_variants"
static sbyte[] const_name = new sbyte[] { 110, 97, 109, 101, 0};// "name"
static sbyte[] const_primitives = new sbyte[] { 112, 114, 105, 109, 105, 116, 105, 118, 101, 115, 0};// "primitives"
static sbyte[] const_weights = new sbyte[] { 119, 101, 105, 103, 104, 116, 115, 0};// "weights"
static sbyte[] const_targetNames = new sbyte[] { 116, 97, 114, 103, 101, 116, 78, 97, 109, 101, 115, 0};// "targetNames"
static sbyte[] const_count = new sbyte[] { 99, 111, 117, 110, 116, 0};// "count"
static sbyte[] const_byteOffset = new sbyte[] { 98, 121, 116, 101, 79, 102, 102, 115, 101, 116, 0};// "byteOffset"
static sbyte[] const_componentType = new sbyte[] { 99, 111, 109, 112, 111, 110, 101, 110, 116, 84, 121, 112, 101, 0};// "componentType"
static sbyte[] const_values = new sbyte[] { 118, 97, 108, 117, 101, 115, 0};// "values"
static sbyte[] const_normalized = new sbyte[] { 110, 111, 114, 109, 97, 108, 105, 122, 101, 100, 0};// "normalized"
static sbyte[] const_type = new sbyte[] { 116, 121, 112, 101, 0};// "type"
static sbyte[] const_SCALAR = new sbyte[] { 83, 67, 65, 76, 65, 82, 0};// "SCALAR"
static sbyte[] const_35 = new sbyte[] { 86, 69, 67, 50, 0};// "VEC2"
static sbyte[] const_36 = new sbyte[] { 86, 69, 67, 51, 0};// "VEC3"
static sbyte[] const_37 = new sbyte[] { 86, 69, 67, 52, 0};// "VEC4"
static sbyte[] const_38 = new sbyte[] { 77, 65, 84, 50, 0};// "MAT2"
static sbyte[] const_39 = new sbyte[] { 77, 65, 84, 51, 0};// "MAT3"
static sbyte[] const_40 = new sbyte[] { 77, 65, 84, 52, 0};// "MAT4"
static sbyte[] const_min = new sbyte[] { 109, 105, 110, 0};// "min"
static sbyte[] const_max = new sbyte[] { 109, 97, 120, 0};// "max"
static sbyte[] const_sparse = new sbyte[] { 115, 112, 97, 114, 115, 101, 0};// "sparse"
static sbyte[] const_offset = new sbyte[] { 111, 102, 102, 115, 101, 116, 0};// "offset"
static sbyte[] const_rotation = new sbyte[] { 114, 111, 116, 97, 116, 105, 111, 110, 0};// "rotation"
static sbyte[] const_scale = new sbyte[] { 115, 99, 97, 108, 101, 0};// "scale"
static sbyte[] const_texCoord = new sbyte[] { 116, 101, 120, 67, 111, 111, 114, 100, 0};// "texCoord"
static sbyte[] const_index = new sbyte[] { 105, 110, 100, 101, 120, 0};// "index"
static sbyte[] const_strength = new sbyte[] { 115, 116, 114, 101, 110, 103, 116, 104, 0};// "strength"
static sbyte[] const_KHR_texture_transform = new sbyte[] { 75, 72, 82, 95, 116, 101, 120, 116, 117, 114, 101, 95, 116, 114, 97, 110, 115, 102, 111, 114, 109, 0};// "KHR_texture_transform"
static sbyte[] const_metallicFactor = new sbyte[] { 109, 101, 116, 97, 108, 108, 105, 99, 70, 97, 99, 116, 111, 114, 0};// "metallicFactor"
static sbyte[] const_roughnessFactor = new sbyte[] { 114, 111, 117, 103, 104, 110, 101, 115, 115, 70, 97, 99, 116, 111, 114, 0};// "roughnessFactor"
static sbyte[] const_baseColorFactor = new sbyte[] { 98, 97, 115, 101, 67, 111, 108, 111, 114, 70, 97, 99, 116, 111, 114, 0};// "baseColorFactor"
static sbyte[] const_baseColorTexture = new sbyte[] { 98, 97, 115, 101, 67, 111, 108, 111, 114, 84, 101, 120, 116, 117, 114, 101, 0};// "baseColorTexture"
static sbyte[] const_metallicRoughnessTexture = new sbyte[] { 109, 101, 116, 97, 108, 108, 105, 99, 82, 111, 117, 103, 104, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "metallicRoughnessTexture"
static sbyte[] const_diffuseFactor = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 70, 97, 99, 116, 111, 114, 0};// "diffuseFactor"
static sbyte[] const_specularFactor = new sbyte[] { 115, 112, 101, 99, 117, 108, 97, 114, 70, 97, 99, 116, 111, 114, 0};// "specularFactor"
static sbyte[] const_glossinessFactor = new sbyte[] { 103, 108, 111, 115, 115, 105, 110, 101, 115, 115, 70, 97, 99, 116, 111, 114, 0};// "glossinessFactor"
static sbyte[] const_diffuseTexture = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 84, 101, 120, 116, 117, 114, 101, 0};// "diffuseTexture"
static sbyte[] const_specularGlossinessTexture = new sbyte[] { 115, 112, 101, 99, 117, 108, 97, 114, 71, 108, 111, 115, 115, 105, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "specularGlossinessTexture"
static sbyte[] const_clearcoatFactor = new sbyte[] { 99, 108, 101, 97, 114, 99, 111, 97, 116, 70, 97, 99, 116, 111, 114, 0};// "clearcoatFactor"
static sbyte[] const_clearcoatRoughnessFactor = new sbyte[] { 99, 108, 101, 97, 114, 99, 111, 97, 116, 82, 111, 117, 103, 104, 110, 101, 115, 115, 70, 97, 99, 116, 111, 114, 0};// "clearcoatRoughnessFactor"
static sbyte[] const_clearcoatTexture = new sbyte[] { 99, 108, 101, 97, 114, 99, 111, 97, 116, 84, 101, 120, 116, 117, 114, 101, 0};// "clearcoatTexture"
static sbyte[] const_clearcoatRoughnessTexture = new sbyte[] { 99, 108, 101, 97, 114, 99, 111, 97, 116, 82, 111, 117, 103, 104, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "clearcoatRoughnessTexture"
static sbyte[] const_clearcoatNormalTexture = new sbyte[] { 99, 108, 101, 97, 114, 99, 111, 97, 116, 78, 111, 114, 109, 97, 108, 84, 101, 120, 116, 117, 114, 101, 0};// "clearcoatNormalTexture"
static sbyte[] const_ior = new sbyte[] { 105, 111, 114, 0};// "ior"
static sbyte[] const_specularColorFactor = new sbyte[] { 115, 112, 101, 99, 117, 108, 97, 114, 67, 111, 108, 111, 114, 70, 97, 99, 116, 111, 114, 0};// "specularColorFactor"
static sbyte[] const_specularTexture = new sbyte[] { 115, 112, 101, 99, 117, 108, 97, 114, 84, 101, 120, 116, 117, 114, 101, 0};// "specularTexture"
static sbyte[] const_specularColorTexture = new sbyte[] { 115, 112, 101, 99, 117, 108, 97, 114, 67, 111, 108, 111, 114, 84, 101, 120, 116, 117, 114, 101, 0};// "specularColorTexture"
static sbyte[] const_transmissionFactor = new sbyte[] { 116, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 70, 97, 99, 116, 111, 114, 0};// "transmissionFactor"
static sbyte[] const_transmissionTexture = new sbyte[] { 116, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 84, 101, 120, 116, 117, 114, 101, 0};// "transmissionTexture"
static sbyte[] const_thicknessFactor = new sbyte[] { 116, 104, 105, 99, 107, 110, 101, 115, 115, 70, 97, 99, 116, 111, 114, 0};// "thicknessFactor"
static sbyte[] const_thicknessTexture = new sbyte[] { 116, 104, 105, 99, 107, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "thicknessTexture"
static sbyte[] const_attenuationColor = new sbyte[] { 97, 116, 116, 101, 110, 117, 97, 116, 105, 111, 110, 67, 111, 108, 111, 114, 0};// "attenuationColor"
static sbyte[] const_attenuationDistance = new sbyte[] { 97, 116, 116, 101, 110, 117, 97, 116, 105, 111, 110, 68, 105, 115, 116, 97, 110, 99, 101, 0};// "attenuationDistance"
static sbyte[] const_sheenColorFactor = new sbyte[] { 115, 104, 101, 101, 110, 67, 111, 108, 111, 114, 70, 97, 99, 116, 111, 114, 0};// "sheenColorFactor"
static sbyte[] const_sheenColorTexture = new sbyte[] { 115, 104, 101, 101, 110, 67, 111, 108, 111, 114, 84, 101, 120, 116, 117, 114, 101, 0};// "sheenColorTexture"
static sbyte[] const_sheenRoughnessFactor = new sbyte[] { 115, 104, 101, 101, 110, 82, 111, 117, 103, 104, 110, 101, 115, 115, 70, 97, 99, 116, 111, 114, 0};// "sheenRoughnessFactor"
static sbyte[] const_sheenRoughnessTexture = new sbyte[] { 115, 104, 101, 101, 110, 82, 111, 117, 103, 104, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "sheenRoughnessTexture"
static sbyte[] const_emissiveStrength = new sbyte[] { 101, 109, 105, 115, 115, 105, 118, 101, 83, 116, 114, 101, 110, 103, 116, 104, 0};// "emissiveStrength"
static sbyte[] const_iridescenceFactor = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 70, 97, 99, 116, 111, 114, 0};// "iridescenceFactor"
static sbyte[] const_iridescenceTexture = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 84, 101, 120, 116, 117, 114, 101, 0};// "iridescenceTexture"
static sbyte[] const_iridescenceIor = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 73, 111, 114, 0};// "iridescenceIor"
static sbyte[] const_iridescenceThicknessMinimum = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 84, 104, 105, 99, 107, 110, 101, 115, 115, 77, 105, 110, 105, 109, 117, 109, 0};// "iridescenceThicknessMinimum"
static sbyte[] const_iridescenceThicknessMaximum = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 84, 104, 105, 99, 107, 110, 101, 115, 115, 77, 97, 120, 105, 109, 117, 109, 0};// "iridescenceThicknessMaximum"
static sbyte[] const_iridescenceThicknessTexture = new sbyte[] { 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 84, 104, 105, 99, 107, 110, 101, 115, 115, 84, 101, 120, 116, 117, 114, 101, 0};// "iridescenceThicknessTexture"
static sbyte[] const_diffuseTransmissionFactor = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 84, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 70, 97, 99, 116, 111, 114, 0};// "diffuseTransmissionFactor"
static sbyte[] const_diffuseTransmissionTexture = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 84, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 84, 101, 120, 116, 117, 114, 101, 0};// "diffuseTransmissionTexture"
static sbyte[] const_diffuseTransmissionColorFactor = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 84, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 67, 111, 108, 111, 114, 70, 97, 99, 116, 111, 114, 0};// "diffuseTransmissionColorFactor"
static sbyte[] const_diffuseTransmissionColorTexture = new sbyte[] { 100, 105, 102, 102, 117, 115, 101, 84, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 67, 111, 108, 111, 114, 84, 101, 120, 116, 117, 114, 101, 0};// "diffuseTransmissionColorTexture"
static sbyte[] const_anisotropyStrength = new sbyte[] { 97, 110, 105, 115, 111, 116, 114, 111, 112, 121, 83, 116, 114, 101, 110, 103, 116, 104, 0};// "anisotropyStrength"
static sbyte[] const_anisotropyRotation = new sbyte[] { 97, 110, 105, 115, 111, 116, 114, 111, 112, 121, 82, 111, 116, 97, 116, 105, 111, 110, 0};// "anisotropyRotation"
static sbyte[] const_anisotropyTexture = new sbyte[] { 97, 110, 105, 115, 111, 116, 114, 111, 112, 121, 84, 101, 120, 116, 117, 114, 101, 0};// "anisotropyTexture"
static sbyte[] const_dispersion = new sbyte[] { 100, 105, 115, 112, 101, 114, 115, 105, 111, 110, 0};// "dispersion"
static sbyte[] const_uri = new sbyte[] { 117, 114, 105, 0};// "uri"
static sbyte[] const_mimeType = new sbyte[] { 109, 105, 109, 101, 84, 121, 112, 101, 0};// "mimeType"
static sbyte[] const_magFilter = new sbyte[] { 109, 97, 103, 70, 105, 108, 116, 101, 114, 0};// "magFilter"
static sbyte[] const_minFilter = new sbyte[] { 109, 105, 110, 70, 105, 108, 116, 101, 114, 0};// "minFilter"
static sbyte[] const_wrapS = new sbyte[] { 119, 114, 97, 112, 83, 0};// "wrapS"
static sbyte[] const_wrapT = new sbyte[] { 119, 114, 97, 112, 84, 0};// "wrapT"
static sbyte[] const_sampler = new sbyte[] { 115, 97, 109, 112, 108, 101, 114, 0};// "sampler"
static sbyte[] const_source = new sbyte[] { 115, 111, 117, 114, 99, 101, 0};// "source"
static sbyte[] const_KHR_texture_basisu = new sbyte[] { 75, 72, 82, 95, 116, 101, 120, 116, 117, 114, 101, 95, 98, 97, 115, 105, 115, 117, 0};// "KHR_texture_basisu"
static sbyte[] const_EXT_texture_webp = new sbyte[] { 69, 88, 84, 95, 116, 101, 120, 116, 117, 114, 101, 95, 119, 101, 98, 112, 0};// "EXT_texture_webp"
static sbyte[] const_pbrMetallicRoughness = new sbyte[] { 112, 98, 114, 77, 101, 116, 97, 108, 108, 105, 99, 82, 111, 117, 103, 104, 110, 101, 115, 115, 0};// "pbrMetallicRoughness"
static sbyte[] const_emissiveFactor = new sbyte[] { 101, 109, 105, 115, 115, 105, 118, 101, 70, 97, 99, 116, 111, 114, 0};// "emissiveFactor"
static sbyte[] const_normalTexture = new sbyte[] { 110, 111, 114, 109, 97, 108, 84, 101, 120, 116, 117, 114, 101, 0};// "normalTexture"
static sbyte[] const_occlusionTexture = new sbyte[] { 111, 99, 99, 108, 117, 115, 105, 111, 110, 84, 101, 120, 116, 117, 114, 101, 0};// "occlusionTexture"
static sbyte[] const_emissiveTexture = new sbyte[] { 101, 109, 105, 115, 115, 105, 118, 101, 84, 101, 120, 116, 117, 114, 101, 0};// "emissiveTexture"
static sbyte[] const_alphaMode = new sbyte[] { 97, 108, 112, 104, 97, 77, 111, 100, 101, 0};// "alphaMode"
static sbyte[] const_OPAQUE = new sbyte[] { 79, 80, 65, 81, 85, 69, 0};// "OPAQUE"
static sbyte[] const_MASK = new sbyte[] { 77, 65, 83, 75, 0};// "MASK"
static sbyte[] const_BLEND = new sbyte[] { 66, 76, 69, 78, 68, 0};// "BLEND"
static sbyte[] const_alphaCutoff = new sbyte[] { 97, 108, 112, 104, 97, 67, 117, 116, 111, 102, 102, 0};// "alphaCutoff"
static sbyte[] const_doubleSided = new sbyte[] { 100, 111, 117, 98, 108, 101, 83, 105, 100, 101, 100, 0};// "doubleSided"
static sbyte[] const_KHR_materials_pbrSpecularGlossiness = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 112, 98, 114, 83, 112, 101, 99, 117, 108, 97, 114, 71, 108, 111, 115, 115, 105, 110, 101, 115, 115, 0};// "KHR_materials_pbrSpecularGlossiness"
static sbyte[] const_KHR_materials_unlit = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 117, 110, 108, 105, 116, 0};// "KHR_materials_unlit"
static sbyte[] const_KHR_materials_clearcoat = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 99, 108, 101, 97, 114, 99, 111, 97, 116, 0};// "KHR_materials_clearcoat"
static sbyte[] const_KHR_materials_ior = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 105, 111, 114, 0};// "KHR_materials_ior"
static sbyte[] const_KHR_materials_specular = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 115, 112, 101, 99, 117, 108, 97, 114, 0};// "KHR_materials_specular"
static sbyte[] const_KHR_materials_transmission = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 116, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 0};// "KHR_materials_transmission"
static sbyte[] const_KHR_materials_volume = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 118, 111, 108, 117, 109, 101, 0};// "KHR_materials_volume"
static sbyte[] const_KHR_materials_sheen = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 115, 104, 101, 101, 110, 0};// "KHR_materials_sheen"
static sbyte[] const_KHR_materials_emissive_strength = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 101, 109, 105, 115, 115, 105, 118, 101, 95, 115, 116, 114, 101, 110, 103, 116, 104, 0};// "KHR_materials_emissive_strength"
static sbyte[] const_KHR_materials_iridescence = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 105, 114, 105, 100, 101, 115, 99, 101, 110, 99, 101, 0};// "KHR_materials_iridescence"
static sbyte[] const_KHR_materials_diffuse_transmission = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 100, 105, 102, 102, 117, 115, 101, 95, 116, 114, 97, 110, 115, 109, 105, 115, 115, 105, 111, 110, 0};// "KHR_materials_diffuse_transmission"
static sbyte[] const_KHR_materials_anisotropy = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 97, 110, 105, 115, 111, 116, 114, 111, 112, 121, 0};// "KHR_materials_anisotropy"
static sbyte[] const_KHR_materials_dispersion = new sbyte[] { 75, 72, 82, 95, 109, 97, 116, 101, 114, 105, 97, 108, 115, 95, 100, 105, 115, 112, 101, 114, 115, 105, 111, 110, 0};// "KHR_materials_dispersion"
static sbyte[] const_buffer = new sbyte[] { 98, 117, 102, 102, 101, 114, 0};// "buffer"
static sbyte[] const_byteLength = new sbyte[] { 98, 121, 116, 101, 76, 101, 110, 103, 116, 104, 0};// "byteLength"
static sbyte[] const_byteStride = new sbyte[] { 98, 121, 116, 101, 83, 116, 114, 105, 100, 101, 0};// "byteStride"
static sbyte[] const_ATTRIBUTES = new sbyte[] { 65, 84, 84, 82, 73, 66, 85, 84, 69, 83, 0};// "ATTRIBUTES"
static sbyte[] const_TRIANGLES = new sbyte[] { 84, 82, 73, 65, 78, 71, 76, 69, 83, 0};// "TRIANGLES"
static sbyte[] const_INDICES = new sbyte[] { 73, 78, 68, 73, 67, 69, 83, 0};// "INDICES"
static sbyte[] const_filter = new sbyte[] { 102, 105, 108, 116, 101, 114, 0};// "filter"
static sbyte[] const_NONE = new sbyte[] { 78, 79, 78, 69, 0};// "NONE"
static sbyte[] const_OCTAHEDRAL = new sbyte[] { 79, 67, 84, 65, 72, 69, 68, 82, 65, 76, 0};// "OCTAHEDRAL"
static sbyte[] const_QUATERNION = new sbyte[] { 81, 85, 65, 84, 69, 82, 78, 73, 79, 78, 0};// "QUATERNION"
static sbyte[] const_EXPONENTIAL = new sbyte[] { 69, 88, 80, 79, 78, 69, 78, 84, 73, 65, 76, 0};// "EXPONENTIAL"
static sbyte[] const_target = new sbyte[] { 116, 97, 114, 103, 101, 116, 0};// "target"
static sbyte[] const_EXT_meshopt_compression = new sbyte[] { 69, 88, 84, 95, 109, 101, 115, 104, 111, 112, 116, 95, 99, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 0};// "EXT_meshopt_compression"
static sbyte[] const_joints = new sbyte[] { 106, 111, 105, 110, 116, 115, 0};// "joints"
static sbyte[] const_skeleton = new sbyte[] { 115, 107, 101, 108, 101, 116, 111, 110, 0};// "skeleton"
static sbyte[] const_inverseBindMatrices = new sbyte[] { 105, 110, 118, 101, 114, 115, 101, 66, 105, 110, 100, 77, 97, 116, 114, 105, 99, 101, 115, 0};// "inverseBindMatrices"
static sbyte[] const_perspective = new sbyte[] { 112, 101, 114, 115, 112, 101, 99, 116, 105, 118, 101, 0};// "perspective"
static sbyte[] const_aspectRatio = new sbyte[] { 97, 115, 112, 101, 99, 116, 82, 97, 116, 105, 111, 0};// "aspectRatio"
static sbyte[] const_yfov = new sbyte[] { 121, 102, 111, 118, 0};// "yfov"
static sbyte[] const_zfar = new sbyte[] { 122, 102, 97, 114, 0};// "zfar"
static sbyte[] const_znear = new sbyte[] { 122, 110, 101, 97, 114, 0};// "znear"
static sbyte[] const_orthographic = new sbyte[] { 111, 114, 116, 104, 111, 103, 114, 97, 112, 104, 105, 99, 0};// "orthographic"
static sbyte[] const_xmag = new sbyte[] { 120, 109, 97, 103, 0};// "xmag"
static sbyte[] const_ymag = new sbyte[] { 121, 109, 97, 103, 0};// "ymag"
static sbyte[] const_color = new sbyte[] { 99, 111, 108, 111, 114, 0};// "color"
static sbyte[] const_intensity = new sbyte[] { 105, 110, 116, 101, 110, 115, 105, 116, 121, 0};// "intensity"
static sbyte[] const_directional = new sbyte[] { 100, 105, 114, 101, 99, 116, 105, 111, 110, 97, 108, 0};// "directional"
static sbyte[] const_point = new sbyte[] { 112, 111, 105, 110, 116, 0};// "point"
static sbyte[] const_spot = new sbyte[] { 115, 112, 111, 116, 0};// "spot"
static sbyte[] const_range = new sbyte[] { 114, 97, 110, 103, 101, 0};// "range"
static sbyte[] const_innerConeAngle = new sbyte[] { 105, 110, 110, 101, 114, 67, 111, 110, 101, 65, 110, 103, 108, 101, 0};// "innerConeAngle"
static sbyte[] const_outerConeAngle = new sbyte[] { 111, 117, 116, 101, 114, 67, 111, 110, 101, 65, 110, 103, 108, 101, 0};// "outerConeAngle"
static sbyte[] const_children = new sbyte[] { 99, 104, 105, 108, 100, 114, 101, 110, 0};// "children"
static sbyte[] const_mesh = new sbyte[] { 109, 101, 115, 104, 0};// "mesh"
static sbyte[] const_skin = new sbyte[] { 115, 107, 105, 110, 0};// "skin"
static sbyte[] const_camera = new sbyte[] { 99, 97, 109, 101, 114, 97, 0};// "camera"
static sbyte[] const_translation = new sbyte[] { 116, 114, 97, 110, 115, 108, 97, 116, 105, 111, 110, 0};// "translation"
static sbyte[] const_matrix = new sbyte[] { 109, 97, 116, 114, 105, 120, 0};// "matrix"
static sbyte[] const_KHR_lights_punctual = new sbyte[] { 75, 72, 82, 95, 108, 105, 103, 104, 116, 115, 95, 112, 117, 110, 99, 116, 117, 97, 108, 0};// "KHR_lights_punctual"
static sbyte[] const_light = new sbyte[] { 108, 105, 103, 104, 116, 0};// "light"
static sbyte[] const_EXT_mesh_gpu_instancing = new sbyte[] { 69, 88, 84, 95, 109, 101, 115, 104, 95, 103, 112, 117, 95, 105, 110, 115, 116, 97, 110, 99, 105, 110, 103, 0};// "EXT_mesh_gpu_instancing"
static sbyte[] const_nodes = new sbyte[] { 110, 111, 100, 101, 115, 0};// "nodes"
static sbyte[] const_input = new sbyte[] { 105, 110, 112, 117, 116, 0};// "input"
static sbyte[] const_output = new sbyte[] { 111, 117, 116, 112, 117, 116, 0};// "output"
static sbyte[] const_interpolation = new sbyte[] { 105, 110, 116, 101, 114, 112, 111, 108, 97, 116, 105, 111, 110, 0};// "interpolation"
static sbyte[] const_LINEAR = new sbyte[] { 76, 73, 78, 69, 65, 82, 0};// "LINEAR"
static sbyte[] const_STEP = new sbyte[] { 83, 84, 69, 80, 0};// "STEP"
static sbyte[] const_CUBICSPLINE = new sbyte[] { 67, 85, 66, 73, 67, 83, 80, 76, 73, 78, 69, 0};// "CUBICSPLINE"
static sbyte[] const_node = new sbyte[] { 110, 111, 100, 101, 0};// "node"
static sbyte[] const_path = new sbyte[] { 112, 97, 116, 104, 0};// "path"
static sbyte[] const_samplers = new sbyte[] { 115, 97, 109, 112, 108, 101, 114, 115, 0};// "samplers"
static sbyte[] const_channels = new sbyte[] { 99, 104, 97, 110, 110, 101, 108, 115, 0};// "channels"
static sbyte[] const_copyright = new sbyte[] { 99, 111, 112, 121, 114, 105, 103, 104, 116, 0};// "copyright"
static sbyte[] const_generator = new sbyte[] { 103, 101, 110, 101, 114, 97, 116, 111, 114, 0};// "generator"
static sbyte[] const_version = new sbyte[] { 118, 101, 114, 115, 105, 111, 110, 0};// "version"
static sbyte[] const_minVersion = new sbyte[] { 109, 105, 110, 86, 101, 114, 115, 105, 111, 110, 0};// "minVersion"
static sbyte[] const_asset = new sbyte[] { 97, 115, 115, 101, 116, 0};// "asset"
static sbyte[] const_meshes = new sbyte[] { 109, 101, 115, 104, 101, 115, 0};// "meshes"
static sbyte[] const_accessors = new sbyte[] { 97, 99, 99, 101, 115, 115, 111, 114, 115, 0};// "accessors"
static sbyte[] const_bufferViews = new sbyte[] { 98, 117, 102, 102, 101, 114, 86, 105, 101, 119, 115, 0};// "bufferViews"
static sbyte[] const_buffers = new sbyte[] { 98, 117, 102, 102, 101, 114, 115, 0};// "buffers"
static sbyte[] const_materials = new sbyte[] { 109, 97, 116, 101, 114, 105, 97, 108, 115, 0};// "materials"
static sbyte[] const_images = new sbyte[] { 105, 109, 97, 103, 101, 115, 0};// "images"
static sbyte[] const_textures = new sbyte[] { 116, 101, 120, 116, 117, 114, 101, 115, 0};// "textures"
static sbyte[] const_skins = new sbyte[] { 115, 107, 105, 110, 115, 0};// "skins"
static sbyte[] const_cameras = new sbyte[] { 99, 97, 109, 101, 114, 97, 115, 0};// "cameras"
static sbyte[] const_scenes = new sbyte[] { 115, 99, 101, 110, 101, 115, 0};// "scenes"
static sbyte[] const_scene = new sbyte[] { 115, 99, 101, 110, 101, 0};// "scene"
static sbyte[] const_animations = new sbyte[] { 97, 110, 105, 109, 97, 116, 105, 111, 110, 115, 0};// "animations"
static sbyte[] const_lights = new sbyte[] { 108, 105, 103, 104, 116, 115, 0};// "lights"
static sbyte[] const_extensionsUsed = new sbyte[] { 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 85, 115, 101, 100, 0};// "extensionsUsed"
static sbyte[] const_extensionsRequired = new sbyte[] { 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 101, 113, 117, 105, 114, 101, 100, 0};// "extensionsRequired"
public static cgltf_result cgltf_parse(cgltf_options* options, void* data, ulong size, cgltf_data** out_data)
{
    if ((size) < (12))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
    }

    if ((options) == (null))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_invalid_options);
    }

    cgltf_options fixed_options = (cgltf_options)(*options);
    if ((fixed_options.memory.alloc_func) == (IntPtr.Zero))
    {
        fixed_options.memory.SetAllocFunc(cgltf_default_alloc);
    }

    if ((fixed_options.memory.free_func) == (IntPtr.Zero))
    {
        fixed_options.memory.SetFreeFunc(cgltf_default_free);
    }

    uint tmp = 0;
    CRuntime.memcpy(&tmp, data, (ulong)(4));
    if (tmp != GlbMagic)
    {
        if ((fixed_options.type) == (cgltf_file_type.cgltf_file_type_invalid))
        {
            fixed_options.type = (cgltf_file_type)(cgltf_file_type.cgltf_file_type_gltf);
        }
        else if ((fixed_options.type) == (cgltf_file_type.cgltf_file_type_glb))
        {
            return (cgltf_result)(cgltf_result.cgltf_result_unknown_format);
        }
    }

    if ((fixed_options.type) == (cgltf_file_type.cgltf_file_type_gltf))
    {
        cgltf_result json_result1 = (cgltf_result)(cgltf_parse_json(&fixed_options, (byte*)(data), (ulong)(size), out_data));
        if (json_result1 != cgltf_result.cgltf_result_success)
        {
            return (cgltf_result)(json_result1);
        }

        (*out_data)->file_type = (cgltf_file_type)(cgltf_file_type.cgltf_file_type_gltf);
        return (cgltf_result)(cgltf_result.cgltf_result_success);
    }

    byte* ptr = (byte*)(data);
    CRuntime.memcpy(&tmp, ptr + 4, (ulong)(4));
    uint version = (uint)(tmp);
    if (version != GlbVersion)
    {
        return (cgltf_result)((version) < (GlbVersion) ? cgltf_result.cgltf_result_legacy_gltf : cgltf_result.cgltf_result_unknown_format);
    }

    CRuntime.memcpy(&tmp, ptr + 8, (ulong)(4));
    if ((tmp) > (size))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
    }

    byte* json_chunk = ptr + 12;
    if ((12 + 8) > (size))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
    }

    uint json_length = 0;
    CRuntime.memcpy(&json_length, json_chunk, (ulong)(4));
    if ((json_length) > (size - 12 - 8))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
    }

    CRuntime.memcpy(&tmp, json_chunk + 4, (ulong)(4));
    if (tmp != GlbMagicJsonChunk)
    {
        return (cgltf_result)(cgltf_result.cgltf_result_unknown_format);
    }

    json_chunk += 8;
    void* bin = null;
    ulong bin_size = (ulong)(0);
    if ((8) <= (size - 12 - 8 - json_length))
    {
        byte* bin_chunk = json_chunk + json_length;
        uint bin_length = 0;
        CRuntime.memcpy(&bin_length, bin_chunk, (ulong)(4));
        if ((bin_length) > (size - 12 - 8 - json_length - 8))
        {
            return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
        }

        CRuntime.memcpy(&tmp, bin_chunk + 4, (ulong)(4));
        if (tmp != GlbMagicBinChunk)
        {
            return (cgltf_result)(cgltf_result.cgltf_result_unknown_format);
        }

        bin_chunk += 8;
        bin = bin_chunk;
        bin_size = (ulong)(bin_length);
    }

    cgltf_result json_result = (cgltf_result)(cgltf_parse_json(&fixed_options, json_chunk, (ulong)(json_length), out_data));
    if (json_result != cgltf_result.cgltf_result_success)
    {
        return (cgltf_result)(json_result);
    }

    (*out_data)->file_type = (cgltf_file_type)(cgltf_file_type.cgltf_file_type_glb);
    (*out_data)->bin = bin;
    (*out_data)->bin_size = (ulong)(bin_size);
    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static cgltf_result cgltf_parse_file(cgltf_options* options, sbyte* path, cgltf_data** out_data)
{
    if ((options) == (null))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_invalid_options);
    }

    delegate2 file_read = options->file.read != IntPtr.Zero ? options->file.GetRead() : cgltf_default_file_read;
    delegate3 file_release = options->file.release != IntPtr.Zero ? options->file.GetRelease() : cgltf_default_file_release;
    void* file_data = null;
    ulong file_size = (ulong)(0);
    cgltf_result result = (cgltf_result)(file_read(&options->memory, &options->file, path, &file_size, &file_data));
    if (result != cgltf_result.cgltf_result_success)
    {
        return (cgltf_result)(result);
    }

    result = (cgltf_result)(cgltf_parse(options, file_data, (ulong)(file_size), out_data));
    if (result != cgltf_result.cgltf_result_success)
    {
        file_release(&options->memory, &options->file, file_data);
        return (cgltf_result)(result);
    }

    (*out_data)->file_data = file_data;
    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static cgltf_result cgltf_load_buffers(cgltf_options* options, cgltf_data* data, sbyte* gltf_path)
{
    if ((options) == (null))
    {
        return (cgltf_result)(cgltf_result.cgltf_result_invalid_options);
    }

    if (((((data->buffers_count) != 0) && ((data->buffers[0].data) == null)) && ((data->buffers[0].uri) == (null))) && ((data->bin) != null))
    {
        if ((data->bin_size) < (data->buffers[0].size))
        {
            return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
        }

        data->buffers[0].data = data->bin;
        data->buffers[0].data_free_method = (cgltf_data_free_method)(cgltf_data_free_method.cgltf_data_free_method_none);
    }

    for (ulong i = (ulong)(0); (i) < (data->buffers_count); ++i)
    {
        if ((data->buffers[i].data) != null)
        {
            continue;
        }

        sbyte* uri = data->buffers[i].uri;
        if ((uri) == (null))
        {
            continue;
        }

        if ((CRuntime.strncmp(uri, const_0, (ulong)(5))) == (0))
        {
            sbyte* comma = CRuntime.strchr(uri, (int)(44));
            if ((((comma) != null) && ((comma - uri) >= (7))) && ((CRuntime.strncmp(comma - 7, const_1, (ulong)(7))) == (0)))
            {
                cgltf_result res = (cgltf_result)(cgltf_load_buffer_base64(options, (ulong)(data->buffers[i].size), comma + 1, &data->buffers[i].data));
                data->buffers[i].data_free_method = (cgltf_data_free_method)(cgltf_data_free_method.cgltf_data_free_method_memory_free);
                if (res != cgltf_result.cgltf_result_success)
                {
                    return (cgltf_result)(res);
                }
            }
            else
            {
                return (cgltf_result)(cgltf_result.cgltf_result_unknown_format);
            }
        }
        else if (((CRuntime.strstr(uri, const_2)) == (null)) && ((gltf_path) != null))
        {
            cgltf_result res = (cgltf_result)(cgltf_load_buffer_file(options, (ulong)(data->buffers[i].size), uri, gltf_path, &data->buffers[i].data));
            data->buffers[i].data_free_method = (cgltf_data_free_method)(cgltf_data_free_method.cgltf_data_free_method_file_release);
            if (res != cgltf_result.cgltf_result_success)
            {
                return (cgltf_result)(res);
            }
        }
        else
        {
            return (cgltf_result)(cgltf_result.cgltf_result_unknown_format);
        }
    }

    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static cgltf_result cgltf_load_buffer_base64(cgltf_options* options, ulong size, sbyte* base64, void** out_data)
{
    delegate0 memory_alloc = options->memory.alloc_func != IntPtr.Zero ? options->memory.GetAllocFunc() : cgltf_default_alloc;
    delegate1 memory_free = options->memory.free_func != IntPtr.Zero ? options->memory.GetFreeFunc() : cgltf_default_free;
    byte* data = (byte*)(memory_alloc(options->memory.user_data, (ulong)(size)));
    if (data == null)
    {
        return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
    }

    uint buffer = (uint)(0);
    uint buffer_bits = (uint)(0);
    for (ulong i = (ulong)(0); (i) < (size); ++i)
    {
        while ((buffer_bits) < (8))
        {
            sbyte ch = (sbyte)(*base64++);
            int index = (int)(((uint)(ch - 65)) < (26) ? (ch - 65) : ((uint)(ch - 97)) < (26) ? (ch - 97) + 26 : ((uint)(ch - 48)) < (10) ? (ch - 48) + 52 : (ch) == (43) ? 62 : (ch) == (47) ? 63 : -1);
            if ((index) < (0))
            {
                memory_free(options->memory.user_data, data);
                return (cgltf_result)(cgltf_result.cgltf_result_io_error);
            }

            buffer = (uint)((buffer << 6) | (uint)index);
            buffer_bits += (uint)(6);
        }

        data[i] = ((byte)(buffer >> ((int)buffer_bits - 8)));
        buffer_bits -= (uint)(8);
    }

    *out_data = data;
    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static ulong cgltf_decode_string(sbyte* _string_)
{
    sbyte* read = _string_ + CRuntime.strcspn(_string_, const_3);
    if ((*read) == (0))
    {
        return (ulong)(read - _string_);
    }

    sbyte* write = _string_;
    sbyte* last = _string_;
    for (;;)
    {
        ulong written = (ulong)(read - last);
        CRuntime.memmove(write, last, (ulong)(written));
        write += written;
        if ((*read++) == (0))
        {
            break;
        }

        switch (*read++)
        {
            case 34:
                *write++ = (sbyte)(34);
                break;
            case 47:
                *write++ = (sbyte)(47);
                break;
            case 92:
                *write++ = (sbyte)(92);
                break;
            case 98:
                *write++ = (sbyte)(8);
                break;
            case 102:
                *write++ = (sbyte)(12);
                break;
            case 114:
                *write++ = (sbyte)(13);
                break;
            case 110:
                *write++ = (sbyte)(10);
                break;
            case 116:
                *write++ = (sbyte)(9);
                break;
            case 117:
            {
                int character = (int)(0);
                for (ulong i = (ulong)(0); (i) < (4); ++i)
                {
                    character = (int)((character << 4) + cgltf_unhex((sbyte)(*read++)));
                }

                if ((character) <= (0x7F))
                {
                    *write++ = (sbyte)(character & 0xFF);
                }
                else if ((character) <= (0x7FF))
                {
                    *write++ = (sbyte)(0xC0 | ((character >> 6) & 0xFF));
                    *write++ = (sbyte)(0x80 | (character & 0x3F));
                }
                else
                {
                    *write++ = (sbyte)(0xE0 | ((character >> 12) & 0xFF));
                    *write++ = (sbyte)(0x80 | ((character >> 6) & 0x3F));
                    *write++ = (sbyte)(0x80 | (character & 0x3F));
                }

                break;
            }

            default:
                break;
        }

        last = read;
        read += CRuntime.strcspn(read, const_3);
    }

    *write = (sbyte)(0);
    return (ulong)(write - _string_);
}
public static ulong cgltf_decode_uri(sbyte* uri)
{
    sbyte* write = uri;
    sbyte* i = uri;
    while ((*i) != 0)
    {
        if ((*i) == (37))
        {
            int ch1 = (int)(cgltf_unhex((sbyte)(i[1])));
            if ((ch1) >= (0))
            {
                int ch2 = (int)(cgltf_unhex((sbyte)(i[2])));
                if ((ch2) >= (0))
                {
                    *write++ = ((sbyte)(ch1 * 16 + ch2));
                    i += 3;
                    continue;
                }
            }
        }

        *write++ = (sbyte)(*i++);
    }

    *write = (sbyte)(0);
    return (ulong)(write - uri);
}
public static cgltf_result cgltf_validate(cgltf_data* data)
{
    for (ulong i = (ulong)(0); (i) < (data->accessors_count); ++i)
    {
        cgltf_accessor* accessor = &data->accessors[i];
        if ((data->accessors[i].component_type) == (cgltf_component_type.cgltf_component_type_invalid))
            return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        if ((data->accessors[i].type) == (cgltf_type.cgltf_type_invalid))
            return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        ulong element_size = (ulong)(cgltf_calc_size((cgltf_type)(accessor->type), (cgltf_component_type)(accessor->component_type)));
        if ((accessor->buffer_view) != null)
        {
            ulong req_size = (ulong)(accessor->offset + accessor->stride * (accessor->count - 1) + element_size);
            if ((accessor->buffer_view->size) < (req_size))
                return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
        }

        if ((accessor->is_sparse) != 0)
        {
            cgltf_accessor_sparse* sparse = &accessor->sparse;
            ulong indices_component_size = (ulong)(cgltf_component_size((cgltf_component_type)(sparse->indices_component_type)));
            ulong indices_req_size = (ulong)(sparse->indices_byte_offset + indices_component_size * sparse->count);
            ulong values_req_size = (ulong)(sparse->values_byte_offset + element_size * sparse->count);
            if (((sparse->indices_buffer_view->size) < (indices_req_size)) || ((sparse->values_buffer_view->size) < (values_req_size)))
                return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
            if (((sparse->indices_component_type != cgltf_component_type.cgltf_component_type_r_8u) && (sparse->indices_component_type != cgltf_component_type.cgltf_component_type_r_16u)) && (sparse->indices_component_type != cgltf_component_type.cgltf_component_type_r_32u))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((sparse->indices_buffer_view->buffer->data) != null)
            {
                ulong index_bound = (ulong)(cgltf_calc_index_bound(sparse->indices_buffer_view, (ulong)(sparse->indices_byte_offset), (cgltf_component_type)(sparse->indices_component_type), (ulong)(sparse->count)));
                if ((index_bound) >= (accessor->count))
                    return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
            }
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->buffer_views_count); ++i)
    {
        ulong req_size = (ulong)(data->buffer_views[i].offset + data->buffer_views[i].size);
        if (((data->buffer_views[i].buffer) != null) && ((data->buffer_views[i].buffer->size) < (req_size)))
            return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
        if ((data->buffer_views[i].has_meshopt_compression) != 0)
        {
            cgltf_meshopt_compression* mc = &data->buffer_views[i].meshopt_compression;
            if (((mc->buffer) == (null)) || ((mc->buffer->size) < (mc->offset + mc->size)))
                return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
            if (((data->buffer_views[i].stride) != 0) && (mc->stride != data->buffer_views[i].stride))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (data->buffer_views[i].size != mc->stride * mc->count)
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_invalid))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_attributes)) && (!(((mc->stride % 4) == (0)) && ((mc->stride) <= (256)))))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_triangles)) && (mc->count % 3 != 0))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_triangles)) || ((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_indices))) && (mc->stride != 2)) && (mc->stride != 4))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_triangles)) || ((mc->mode) == (cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_indices))) && (mc->filter != cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_none))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((((mc->filter) == (cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_octahedral)) && (mc->stride != 4)) && (mc->stride != 8))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((mc->filter) == (cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_quaternion)) && (mc->stride != 8))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->meshes_count); ++i)
    {
        if ((data->meshes[i].weights) != null)
        {
            if (((data->meshes[i].primitives_count) != 0) && (data->meshes[i].primitives[0].targets_count != data->meshes[i].weights_count))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }

        if ((data->meshes[i].target_names) != null)
        {
            if (((data->meshes[i].primitives_count) != 0) && (data->meshes[i].primitives[0].targets_count != data->meshes[i].target_names_count))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }

        for (ulong j = (ulong)(0); (j) < (data->meshes[i].primitives_count); ++j)
        {
            if ((data->meshes[i].primitives[j].type) == (cgltf_primitive_type.cgltf_primitive_type_invalid))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (data->meshes[i].primitives[j].targets_count != data->meshes[i].primitives[0].targets_count)
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((data->meshes[i].primitives[j].attributes_count) == (0))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            cgltf_accessor* first = data->meshes[i].primitives[j].attributes[0].data;
            if ((first->count) == (0))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].attributes_count); ++k)
            {
                if (data->meshes[i].primitives[j].attributes[k].data->count != first->count)
                    return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].targets_count); ++k)
            {
                for (ulong m = (ulong)(0); (m) < (data->meshes[i].primitives[j].targets[k].attributes_count); ++m)
                {
                    if (data->meshes[i].primitives[j].targets[k].attributes[m].data->count != first->count)
                        return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
                }
            }

            cgltf_accessor* indices = data->meshes[i].primitives[j].indices;
            if (((((indices) != null) && (indices->component_type != cgltf_component_type.cgltf_component_type_r_8u)) && (indices->component_type != cgltf_component_type.cgltf_component_type_r_16u)) && (indices->component_type != cgltf_component_type.cgltf_component_type_r_32u))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((indices) != null) && (indices->type != cgltf_type.cgltf_type_scalar))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if (((indices) != null) && (indices->stride != cgltf_component_size((cgltf_component_type)(indices->component_type))))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((((indices) != null) && ((indices->buffer_view) != null)) && ((indices->buffer_view->buffer->data) != null))
            {
                ulong index_bound = (ulong)(cgltf_calc_index_bound(indices->buffer_view, (ulong)(indices->offset), (cgltf_component_type)(indices->component_type), (ulong)(indices->count)));
                if ((index_bound) >= (first->count))
                    return (cgltf_result)(cgltf_result.cgltf_result_data_too_short);
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].mappings_count); ++k)
            {
                if ((data->meshes[i].primitives[j].mappings[k].variant) >= (data->variants_count))
                    return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            }
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->nodes_count); ++i)
    {
        if (((data->nodes[i].weights) != null) && ((data->nodes[i].mesh) != null))
        {
            if (((data->nodes[i].mesh->primitives_count) != 0) && (data->nodes[i].mesh->primitives[0].targets_count != data->nodes[i].weights_count))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }

        if ((data->nodes[i].has_mesh_gpu_instancing) != 0)
        {
            if ((data->nodes[i].mesh) == (null))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            if ((data->nodes[i].mesh_gpu_instancing.attributes_count) == (0))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            cgltf_accessor* first = data->nodes[i].mesh_gpu_instancing.attributes[0].data;
            for (ulong k = (ulong)(0); (k) < (data->nodes[i].mesh_gpu_instancing.attributes_count); ++k)
            {
                if (data->nodes[i].mesh_gpu_instancing.attributes[k].data->count != first->count)
                    return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            }
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->nodes_count); ++i)
    {
        cgltf_node* p1 = data->nodes[i].parent;
        cgltf_node* p2 = p1 != null ? p1->parent : null;
        while (((p1) != null) && ((p2) != null))
        {
            if ((p1) == (p2))
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
            p1 = p1->parent;
            p2 = p2->parent != null ? p2->parent->parent : null;
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->scenes_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->scenes[i].nodes_count); ++j)
        {
            if ((data->scenes[i].nodes[j]->parent) != null)
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->animations_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->animations[i].channels_count); ++j)
        {
            cgltf_animation_channel* channel = &data->animations[i].channels[j];
            if (channel->target_node == null)
            {
                continue;
            }

            ulong components = (ulong)(1);
            if ((channel->target_path) == (cgltf_animation_path_type.cgltf_animation_path_type_weights))
            {
                if ((channel->target_node->mesh == null) || (channel->target_node->mesh->primitives_count == 0))
                    return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
                components = (ulong)(channel->target_node->mesh->primitives[0].targets_count);
            }

            ulong values = (ulong)((channel->sampler->interpolation) == (cgltf_interpolation_type.cgltf_interpolation_type_cubic_spline) ? 3 : 1);
            if (channel->sampler->input->count * components * values != channel->sampler->output->count)
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->variants_count); ++i)
    {
        if (data->variants[i].name == null)
            return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
    }

    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static void cgltf_free(cgltf_data* data)
{
    if (data == null)
    {
        return;
    }

    delegate3 file_release = data->file.release != IntPtr.Zero ? data->file.GetRelease() : cgltf_default_file_release;
    data->memory.GetFreeFunc()(data->memory.user_data, data->asset.copyright);
    data->memory.GetFreeFunc()(data->memory.user_data, data->asset.generator);
    data->memory.GetFreeFunc()(data->memory.user_data, data->asset.version);
    data->memory.GetFreeFunc()(data->memory.user_data, data->asset.min_version);
    cgltf_free_extensions(data, data->asset.extensions, (ulong)(data->asset.extensions_count));
    cgltf_free_extras(data, &data->asset.extras);
    for (ulong i = (ulong)(0); (i) < (data->accessors_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->accessors[i].name);
        cgltf_free_extensions(data, data->accessors[i].extensions, (ulong)(data->accessors[i].extensions_count));
        cgltf_free_extras(data, &data->accessors[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->accessors);
    for (ulong i = (ulong)(0); (i) < (data->buffer_views_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->buffer_views[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, data->buffer_views[i].data);
        cgltf_free_extensions(data, data->buffer_views[i].extensions, (ulong)(data->buffer_views[i].extensions_count));
        cgltf_free_extras(data, &data->buffer_views[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->buffer_views);
    for (ulong i = (ulong)(0); (i) < (data->buffers_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->buffers[i].name);
        if ((data->buffers[i].data_free_method) == (cgltf_data_free_method.cgltf_data_free_method_file_release))
        {
            file_release(&data->memory, &data->file, data->buffers[i].data);
        }
        else if ((data->buffers[i].data_free_method) == (cgltf_data_free_method.cgltf_data_free_method_memory_free))
        {
            data->memory.GetFreeFunc()(data->memory.user_data, data->buffers[i].data);
        }

        data->memory.GetFreeFunc()(data->memory.user_data, data->buffers[i].uri);
        cgltf_free_extensions(data, data->buffers[i].extensions, (ulong)(data->buffers[i].extensions_count));
        cgltf_free_extras(data, &data->buffers[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->buffers);
    for (ulong i = (ulong)(0); (i) < (data->meshes_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].name);
        for (ulong j = (ulong)(0); (j) < (data->meshes[i].primitives_count); ++j)
        {
            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].attributes_count); ++k)
            {
                data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].attributes[k].name);
            }

            data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].attributes);
            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].targets_count); ++k)
            {
                for (ulong m = (ulong)(0); (m) < (data->meshes[i].primitives[j].targets[k].attributes_count); ++m)
                {
                    data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].targets[k].attributes[m].name);
                }

                data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].targets[k].attributes);
            }

            data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].targets);
            if ((data->meshes[i].primitives[j].has_draco_mesh_compression) != 0)
            {
                for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].draco_mesh_compression.attributes_count); ++k)
                {
                    data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].draco_mesh_compression.attributes[k].name);
                }

                data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].draco_mesh_compression.attributes);
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].mappings_count); ++k)
            {
                cgltf_free_extras(data, &data->meshes[i].primitives[j].mappings[k].extras);
            }

            data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives[j].mappings);
            cgltf_free_extensions(data, data->meshes[i].primitives[j].extensions, (ulong)(data->meshes[i].primitives[j].extensions_count));
            cgltf_free_extras(data, &data->meshes[i].primitives[j].extras);
        }

        data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].primitives);
        data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].weights);
        for (ulong j = (ulong)(0); (j) < (data->meshes[i].target_names_count); ++j)
        {
            data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].target_names[j]);
        }

        cgltf_free_extensions(data, data->meshes[i].extensions, (ulong)(data->meshes[i].extensions_count));
        cgltf_free_extras(data, &data->meshes[i].extras);
        data->memory.GetFreeFunc()(data->memory.user_data, data->meshes[i].target_names);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->meshes);
    for (ulong i = (ulong)(0); (i) < (data->materials_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->materials[i].name);
        cgltf_free_extensions(data, data->materials[i].extensions, (ulong)(data->materials[i].extensions_count));
        cgltf_free_extras(data, &data->materials[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->materials);
    for (ulong i = (ulong)(0); (i) < (data->images_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->images[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, data->images[i].uri);
        data->memory.GetFreeFunc()(data->memory.user_data, data->images[i].mime_type);
        cgltf_free_extensions(data, data->images[i].extensions, (ulong)(data->images[i].extensions_count));
        cgltf_free_extras(data, &data->images[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->images);
    for (ulong i = (ulong)(0); (i) < (data->textures_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->textures[i].name);
        cgltf_free_extensions(data, data->textures[i].extensions, (ulong)(data->textures[i].extensions_count));
        cgltf_free_extras(data, &data->textures[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->textures);
    for (ulong i = (ulong)(0); (i) < (data->samplers_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->samplers[i].name);
        cgltf_free_extensions(data, data->samplers[i].extensions, (ulong)(data->samplers[i].extensions_count));
        cgltf_free_extras(data, &data->samplers[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->samplers);
    for (ulong i = (ulong)(0); (i) < (data->skins_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->skins[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, data->skins[i].joints);
        cgltf_free_extensions(data, data->skins[i].extensions, (ulong)(data->skins[i].extensions_count));
        cgltf_free_extras(data, &data->skins[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->skins);
    for (ulong i = (ulong)(0); (i) < (data->cameras_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->cameras[i].name);
        if ((data->cameras[i].type) == (cgltf_camera_type.cgltf_camera_type_perspective))
        {
            cgltf_free_extras(data, &data->cameras[i].data.perspective.extras);
        }
        else if ((data->cameras[i].type) == (cgltf_camera_type.cgltf_camera_type_orthographic))
        {
            cgltf_free_extras(data, &data->cameras[i].data.orthographic.extras);
        }

        cgltf_free_extensions(data, data->cameras[i].extensions, (ulong)(data->cameras[i].extensions_count));
        cgltf_free_extras(data, &data->cameras[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->cameras);
    for (ulong i = (ulong)(0); (i) < (data->lights_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->lights[i].name);
        cgltf_free_extras(data, &data->lights[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->lights);
    for (ulong i = (ulong)(0); (i) < (data->nodes_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->nodes[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, data->nodes[i].children);
        data->memory.GetFreeFunc()(data->memory.user_data, data->nodes[i].weights);
        if ((data->nodes[i].has_mesh_gpu_instancing) != 0)
        {
            for (ulong j = (ulong)(0); (j) < (data->nodes[i].mesh_gpu_instancing.attributes_count); ++j)
            {
                data->memory.GetFreeFunc()(data->memory.user_data, data->nodes[i].mesh_gpu_instancing.attributes[j].name);
            }

            data->memory.GetFreeFunc()(data->memory.user_data, data->nodes[i].mesh_gpu_instancing.attributes);
        }

        cgltf_free_extensions(data, data->nodes[i].extensions, (ulong)(data->nodes[i].extensions_count));
        cgltf_free_extras(data, &data->nodes[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->nodes);
    for (ulong i = (ulong)(0); (i) < (data->scenes_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->scenes[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, data->scenes[i].nodes);
        cgltf_free_extensions(data, data->scenes[i].extensions, (ulong)(data->scenes[i].extensions_count));
        cgltf_free_extras(data, &data->scenes[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->scenes);
    for (ulong i = (ulong)(0); (i) < (data->animations_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->animations[i].name);
        for (ulong j = (ulong)(0); (j) < (data->animations[i].samplers_count); ++j)
        {
            cgltf_free_extensions(data, data->animations[i].samplers[j].extensions, (ulong)(data->animations[i].samplers[j].extensions_count));
            cgltf_free_extras(data, &data->animations[i].samplers[j].extras);
        }

        data->memory.GetFreeFunc()(data->memory.user_data, data->animations[i].samplers);
        for (ulong j = (ulong)(0); (j) < (data->animations[i].channels_count); ++j)
        {
            cgltf_free_extensions(data, data->animations[i].channels[j].extensions, (ulong)(data->animations[i].channels[j].extensions_count));
            cgltf_free_extras(data, &data->animations[i].channels[j].extras);
        }

        data->memory.GetFreeFunc()(data->memory.user_data, data->animations[i].channels);
        cgltf_free_extensions(data, data->animations[i].extensions, (ulong)(data->animations[i].extensions_count));
        cgltf_free_extras(data, &data->animations[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->animations);
    for (ulong i = (ulong)(0); (i) < (data->variants_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->variants[i].name);
        cgltf_free_extras(data, &data->variants[i].extras);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->variants);
    cgltf_free_extensions(data, data->data_extensions, (ulong)(data->data_extensions_count));
    cgltf_free_extras(data, &data->extras);
    for (ulong i = (ulong)(0); (i) < (data->extensions_used_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->extensions_used[i]);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->extensions_used);
    for (ulong i = (ulong)(0); (i) < (data->extensions_required_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, data->extensions_required[i]);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, data->extensions_required);
    file_release(&data->memory, &data->file, data->file_data);
    data->memory.GetFreeFunc()(data->memory.user_data, data);
}
public static void cgltf_node_transform_local(cgltf_node* node, float* out_matrix)
{
    float* lm = out_matrix;
    if ((node->has_matrix) != 0)
    {
        CRuntime.memcpy(lm, node->matrix, (ulong)(sizeof(float) * 16));
    }
    else
    {
        float tx = (float)(node->translation[0]);
        float ty = (float)(node->translation[1]);
        float tz = (float)(node->translation[2]);
        float qx = (float)(node->rotation[0]);
        float qy = (float)(node->rotation[1]);
        float qz = (float)(node->rotation[2]);
        float qw = (float)(node->rotation[3]);
        float sx = (float)(node->scale[0]);
        float sy = (float)(node->scale[1]);
        float sz = (float)(node->scale[2]);
        lm[0] = (float)((1 - 2 * qy * qy - 2 * qz * qz) * sx);
        lm[1] = (float)((2 * qx * qy + 2 * qz * qw) * sx);
        lm[2] = (float)((2 * qx * qz - 2 * qy * qw) * sx);
        lm[3] = (float)(0.0f);
        lm[4] = (float)((2 * qx * qy - 2 * qz * qw) * sy);
        lm[5] = (float)((1 - 2 * qx * qx - 2 * qz * qz) * sy);
        lm[6] = (float)((2 * qy * qz + 2 * qx * qw) * sy);
        lm[7] = (float)(0.0f);
        lm[8] = (float)((2 * qx * qz + 2 * qy * qw) * sz);
        lm[9] = (float)((2 * qy * qz - 2 * qx * qw) * sz);
        lm[10] = (float)((1 - 2 * qx * qx - 2 * qy * qy) * sz);
        lm[11] = (float)(0.0f);
        lm[12] = (float)(tx);
        lm[13] = (float)(ty);
        lm[14] = (float)(tz);
        lm[15] = (float)(1.0f);
    }
}
public static void cgltf_node_transform_world(cgltf_node* node, float* out_matrix)
{
    float* lm = out_matrix;
    cgltf_node_transform_local(node, lm);
    cgltf_node* parent = node->parent;
    while ((parent) != null)
    {
        float* pm = stackalloc float[16];
        cgltf_node_transform_local(parent, pm);
        for (int i = (int)(0); (i) < (4); ++i)
        {
            float l0 = (float)(lm[i * 4 + 0]);
            float l1 = (float)(lm[i * 4 + 1]);
            float l2 = (float)(lm[i * 4 + 2]);
            float r0 = (float)(l0 * pm[0] + l1 * pm[4] + l2 * pm[8]);
            float r1 = (float)(l0 * pm[1] + l1 * pm[5] + l2 * pm[9]);
            float r2 = (float)(l0 * pm[2] + l1 * pm[6] + l2 * pm[10]);
            lm[i * 4 + 0] = (float)(r0);
            lm[i * 4 + 1] = (float)(r1);
            lm[i * 4 + 2] = (float)(r2);
        }

        lm[12] += (float)(pm[12]);
        lm[13] += (float)(pm[13]);
        lm[14] += (float)(pm[14]);
        parent = parent->parent;
    }
}
public static byte* cgltf_buffer_view_data(cgltf_buffer_view* view)
{
    if ((view->data) != null)
        return (byte*)(view->data);
    if (view->buffer->data == null)
        return null;
    byte* result = (byte*)(view->buffer->data);
    result += view->offset;
    return result;
}
public static cgltf_accessor* cgltf_find_accessor(cgltf_primitive* prim, cgltf_attribute_type type, int index)
{
    for (ulong i = (ulong)(0); (i) < (prim->attributes_count); ++i)
    {
        cgltf_attribute* attr = &prim->attributes[i];
        if (((attr->type) == (type)) && ((attr->index) == (index)))
            return attr->data;
    }

    return null;
}
public static int cgltf_accessor_read_float(cgltf_accessor* accessor, ulong index, float* _out_, ulong element_size)
{
    if ((accessor->is_sparse) != 0)
    {
        return (int)(0);
    }

    if ((accessor->buffer_view) == (null))
    {
        CRuntime.memset(_out_, (int)(0), (ulong)(element_size * sizeof(float)));
        return (int)(1);
    }

    byte* element = cgltf_buffer_view_data(accessor->buffer_view);
    if ((element) == (null))
    {
        return (int)(0);
    }

    element += accessor->offset + accessor->stride * index;
    return (int)(cgltf_element_read_float(element, (cgltf_type)(accessor->type), (cgltf_component_type)(accessor->component_type), (int)(accessor->normalized), _out_, (ulong)(element_size)));
}
public static int cgltf_accessor_read_uint(cgltf_accessor* accessor, ulong index, uint* _out_, ulong element_size)
{
    if ((accessor->is_sparse) != 0)
    {
        return (int)(0);
    }

    if ((accessor->buffer_view) == (null))
    {
        CRuntime.memset(_out_, (int)(0), (ulong)(element_size * sizeof(uint)));
        return (int)(1);
    }

    byte* element = cgltf_buffer_view_data(accessor->buffer_view);
    if ((element) == (null))
    {
        return (int)(0);
    }

    element += accessor->offset + accessor->stride * index;
    return (int)(cgltf_element_read_uint(element, (cgltf_type)(accessor->type), (cgltf_component_type)(accessor->component_type), _out_, (ulong)(element_size)));
}
public static ulong cgltf_accessor_read_index(cgltf_accessor* accessor, ulong index)
{
    if ((accessor->is_sparse) != 0)
    {
        return (ulong)(0);
    }

    if ((accessor->buffer_view) == (null))
    {
        return (ulong)(0);
    }

    byte* element = cgltf_buffer_view_data(accessor->buffer_view);
    if ((element) == (null))
    {
        return (ulong)(0);
    }

    element += accessor->offset + accessor->stride * index;
    return (ulong)(cgltf_component_read_index(element, (cgltf_component_type)(accessor->component_type)));
}
public static ulong cgltf_num_components(cgltf_type type)
{
    switch (type)
    {
        case cgltf_type.cgltf_type_vec2:
            return (ulong)(2);
        case cgltf_type.cgltf_type_vec3:
            return (ulong)(3);
        case cgltf_type.cgltf_type_vec4:
            return (ulong)(4);
        case cgltf_type.cgltf_type_mat2:
            return (ulong)(4);
        case cgltf_type.cgltf_type_mat3:
            return (ulong)(9);
        case cgltf_type.cgltf_type_mat4:
            return (ulong)(16);
        case cgltf_type.cgltf_type_invalid:
        case cgltf_type.cgltf_type_scalar:
        default:
            return (ulong)(1);
    }
}
public static ulong cgltf_component_size(cgltf_component_type component_type)
{
    switch (component_type)
    {
        case cgltf_component_type.cgltf_component_type_r_8:
        case cgltf_component_type.cgltf_component_type_r_8u:
            return (ulong)(1);
        case cgltf_component_type.cgltf_component_type_r_16:
        case cgltf_component_type.cgltf_component_type_r_16u:
            return (ulong)(2);
        case cgltf_component_type.cgltf_component_type_r_32u:
        case cgltf_component_type.cgltf_component_type_r_32f:
            return (ulong)(4);
        case cgltf_component_type.cgltf_component_type_invalid:
        default:
            return (ulong)(0);
    }
}
public static ulong cgltf_calc_size(cgltf_type type, cgltf_component_type component_type)
{
    ulong component_size = (ulong)(cgltf_component_size((cgltf_component_type)(component_type)));
    if (((type) == (cgltf_type.cgltf_type_mat2)) && ((component_size) == (1)))
    {
        return (ulong)(8 * component_size);
    }
    else if (((type) == (cgltf_type.cgltf_type_mat3)) && (((component_size) == (1)) || ((component_size) == (2))))
    {
        return (ulong)(12 * component_size);
    }

    return (ulong)(component_size * cgltf_num_components((cgltf_type)(type)));
}
public static ulong cgltf_accessor_unpack_floats(cgltf_accessor* accessor, float* _out_, ulong float_count)
{
    ulong floats_per_element = (ulong)(cgltf_num_components((cgltf_type)(accessor->type)));
    ulong available_floats = (ulong)(accessor->count * floats_per_element);
    if ((_out_) == (null))
    {
        return (ulong)(available_floats);
    }

    float_count = (ulong)((available_floats) < (float_count) ? available_floats : float_count);
    ulong element_count = (ulong)(float_count / floats_per_element);
    if ((accessor->buffer_view) == (null))
    {
        CRuntime.memset(_out_, (int)(0), (ulong)(element_count * floats_per_element * sizeof(float)));
    }
    else
    {
        byte* element = cgltf_buffer_view_data(accessor->buffer_view);
        if ((element) == (null))
        {
            return (ulong)(0);
        }

        element += accessor->offset;
        if (((accessor->component_type) == (cgltf_component_type.cgltf_component_type_r_32f)) && ((accessor->stride) == (floats_per_element * sizeof(float))))
        {
            CRuntime.memcpy(_out_, element, (ulong)(element_count * floats_per_element * sizeof(float)));
        }
        else
        {
            float* dest = _out_;
            for (ulong index = (ulong)(0); (index) < (element_count); index++, dest += floats_per_element, element += accessor->stride)
            {
                if (cgltf_element_read_float(element, (cgltf_type)(accessor->type), (cgltf_component_type)(accessor->component_type), (int)(accessor->normalized), dest, (ulong)(floats_per_element)) == 0)
                {
                    return (ulong)(0);
                }
            }
        }
    }

    if ((accessor->is_sparse) != 0)
    {
        cgltf_accessor_sparse* sparse = &accessor->sparse;
        byte* index_data = cgltf_buffer_view_data(sparse->indices_buffer_view);
        byte* reader_head = cgltf_buffer_view_data(sparse->values_buffer_view);
        if (((index_data) == (null)) || ((reader_head) == (null)))
        {
            return (ulong)(0);
        }

        index_data += sparse->indices_byte_offset;
        reader_head += sparse->values_byte_offset;
        ulong index_stride = (ulong)(cgltf_component_size((cgltf_component_type)(sparse->indices_component_type)));
        for (ulong reader_index = (ulong)(0); (reader_index) < (sparse->count); reader_index++, index_data += index_stride, reader_head += accessor->stride)
        {
            ulong writer_index = (ulong)(cgltf_component_read_index(index_data, (cgltf_component_type)(sparse->indices_component_type)));
            float* writer_head = _out_ + writer_index * floats_per_element;
            if (cgltf_element_read_float(reader_head, (cgltf_type)(accessor->type), (cgltf_component_type)(accessor->component_type), (int)(accessor->normalized), writer_head, (ulong)(floats_per_element)) == 0)
            {
                return (ulong)(0);
            }
        }
    }

    return (ulong)(element_count * floats_per_element);
}
public static ulong cgltf_accessor_unpack_indices(cgltf_accessor* accessor, void* _out_, ulong out_component_size, ulong index_count)
{
    if ((_out_) == null)
    {
        return (ulong)(accessor->count);
    }

    index_count = (ulong)((accessor->count) < (index_count) ? accessor->count : index_count);
    ulong index_component_size = (ulong)(cgltf_component_size((cgltf_component_type)(accessor->component_type)));
    if ((accessor->is_sparse) != 0)
    {
        return (ulong)(0);
    }

    if ((accessor->buffer_view) == (null))
    {
        return (ulong)(0);
    }

    if ((index_component_size) > (out_component_size))
    {
        return (ulong)(0);
    }

    byte* element = cgltf_buffer_view_data(accessor->buffer_view);
    if ((element) == (null))
    {
        return (ulong)(0);
    }

    element += accessor->offset;
    if (((index_component_size) == (out_component_size)) && ((accessor->stride) == (out_component_size)))
    {
        CRuntime.memcpy(_out_, element, (ulong)(index_count * index_component_size));
        return (ulong)(index_count);
    }

    switch (out_component_size)
    {
        case 2:
            for (ulong index = (ulong)(0); (index) < (index_count); index++, element += accessor->stride)
            {
                ((ushort*)(_out_))[index] = ((ushort)(cgltf_component_read_index(element, (cgltf_component_type)(accessor->component_type))));
            }

            break;
        case 4:
            for (ulong index = (ulong)(0); (index) < (index_count); index++, element += accessor->stride)
            {
                ((uint*)(_out_))[index] = ((uint)(cgltf_component_read_index(element, (cgltf_component_type)(accessor->component_type))));
            }

            break;
        default:
            break;
    }

    return (ulong)(index_count);
}
public static cgltf_result cgltf_copy_extras_json(cgltf_data* data, cgltf_extras* extras, sbyte* dest, ulong* dest_size)
{
    ulong json_size = (ulong)(extras->end_offset - extras->start_offset);
    if (dest == null)
    {
        if ((dest_size) != null)
        {
            *dest_size = (ulong)(json_size + 1);
            return (cgltf_result)(cgltf_result.cgltf_result_success);
        }

        return (cgltf_result)(cgltf_result.cgltf_result_invalid_options);
    }

    if ((*dest_size + 1) < (json_size))
    {
        CRuntime.strncpy(dest, data->json + extras->start_offset, (ulong)(*dest_size - 1));
        dest[*dest_size - 1] = (sbyte)(0);
    }
    else
    {
        CRuntime.strncpy(dest, data->json + extras->start_offset, (ulong)(json_size));
        dest[json_size] = (sbyte)(0);
    }

    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static ulong cgltf_mesh_index(cgltf_data* data, cgltf_mesh* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->meshes)) < (data->meshes_count)) ? 1 : 0));
    return (ulong)(_object_ - data->meshes);
}
public static ulong cgltf_material_index(cgltf_data* data, cgltf_material* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->materials)) < (data->materials_count)) ? 1 : 0));
    return (ulong)(_object_ - data->materials);
}
public static ulong cgltf_accessor_index(cgltf_data* data, cgltf_accessor* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->accessors)) < (data->accessors_count)) ? 1 : 0));
    return (ulong)(_object_ - data->accessors);
}
public static ulong cgltf_buffer_view_index(cgltf_data* data, cgltf_buffer_view* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->buffer_views)) < (data->buffer_views_count)) ? 1 : 0));
    return (ulong)(_object_ - data->buffer_views);
}
public static ulong cgltf_buffer_index(cgltf_data* data, cgltf_buffer* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->buffers)) < (data->buffers_count)) ? 1 : 0));
    return (ulong)(_object_ - data->buffers);
}
public static ulong cgltf_image_index(cgltf_data* data, cgltf_image* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->images)) < (data->images_count)) ? 1 : 0));
    return (ulong)(_object_ - data->images);
}
public static ulong cgltf_texture_index(cgltf_data* data, cgltf_texture* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->textures)) < (data->textures_count)) ? 1 : 0));
    return (ulong)(_object_ - data->textures);
}
public static ulong cgltf_sampler_index(cgltf_data* data, cgltf_sampler* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->samplers)) < (data->samplers_count)) ? 1 : 0));
    return (ulong)(_object_ - data->samplers);
}
public static ulong cgltf_skin_index(cgltf_data* data, cgltf_skin* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->skins)) < (data->skins_count)) ? 1 : 0));
    return (ulong)(_object_ - data->skins);
}
public static ulong cgltf_camera_index(cgltf_data* data, cgltf_camera* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->cameras)) < (data->cameras_count)) ? 1 : 0));
    return (ulong)(_object_ - data->cameras);
}
public static ulong cgltf_light_index(cgltf_data* data, cgltf_light* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->lights)) < (data->lights_count)) ? 1 : 0));
    return (ulong)(_object_ - data->lights);
}
public static ulong cgltf_node_index(cgltf_data* data, cgltf_node* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->nodes)) < (data->nodes_count)) ? 1 : 0));
    return (ulong)(_object_ - data->nodes);
}
public static ulong cgltf_scene_index(cgltf_data* data, cgltf_scene* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->scenes)) < (data->scenes_count)) ? 1 : 0));
    return (ulong)(_object_ - data->scenes);
}
public static ulong cgltf_animation_index(cgltf_data* data, cgltf_animation* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - data->animations)) < (data->animations_count)) ? 1 : 0));
    return (ulong)(_object_ - data->animations);
}
public static ulong cgltf_animation_sampler_index(cgltf_animation* animation, cgltf_animation_sampler* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - animation->samplers)) < (animation->samplers_count)) ? 1 : 0));
    return (ulong)(_object_ - animation->samplers);
}
public static ulong cgltf_animation_channel_index(cgltf_animation* animation, cgltf_animation_channel* _object_)
{
    CRuntime.assert((((_object_) != null) && (((ulong)(_object_ - animation->channels)) < (animation->channels_count)) ? 1 : 0));
    return (ulong)(_object_ - animation->channels);
}
public static void jsmn_init(jsmn_parser* parser)
{
    parser->pos = (ulong)(0);
    parser->toknext = (uint)(0);
    parser->toksuper = (int)(-1);
}
public static int jsmn_parse(jsmn_parser* parser, sbyte* js, ulong len, jsmntok_t* tokens, ulong num_tokens)
{
    int r = 0;
    int i = 0;
    jsmntok_t* token;
    int count = (int)(parser->toknext);
    for (; ((parser->pos) < (len)) && (js[parser->pos] != 0); parser->pos++)
    {
        sbyte c = 0;
        jsmntype_t type = 0;
        c = (sbyte)(js[parser->pos]);
        switch (c)
        {
            case 123:
            case 91:
                count++;
                if ((tokens) == (null))
                {
                    break;
                }

                token = jsmn_alloc_token(parser, tokens, (ulong)(num_tokens));
                if ((token) == (null))
                    return (int)(jsmnerr.JSMN_ERROR_NOMEM);
                if (parser->toksuper != -1)
                {
                    tokens[parser->toksuper].size++;
                    token->parent = (int)(parser->toksuper);
                }

                token->type = (jsmntype_t)((c) == (123) ? jsmntype_t.JSMN_OBJECT : jsmntype_t.JSMN_ARRAY);
                token->start = (long)(parser->pos);
                parser->toksuper = (int)(parser->toknext - 1);
                break;
            case 125:
            case 93:
                if ((tokens) == (null))
                    break;
                type = (jsmntype_t)((c) == (125) ? jsmntype_t.JSMN_OBJECT : jsmntype_t.JSMN_ARRAY);
                if ((parser->toknext) < (1))
                {
                    return (int)(jsmnerr.JSMN_ERROR_INVAL);
                }

                token = &tokens[parser->toknext - 1];
                for (;;)
                {
                    if ((token->start != -1) && ((token->end) == (-1)))
                    {
                        if (token->type != type)
                        {
                            return (int)(jsmnerr.JSMN_ERROR_INVAL);
                        }

                        token->end = (long)(parser->pos + 1);
                        parser->toksuper = (int)(token->parent);
                        break;
                    }

                    if ((token->parent) == (-1))
                    {
                        if ((token->type != type) || ((parser->toksuper) == (-1)))
                        {
                            return (int)(jsmnerr.JSMN_ERROR_INVAL);
                        }

                        break;
                    }

                    token = &tokens[token->parent];
                }

                break;
            case 34:
                r = (int)(jsmn_parse_string(parser, js, (ulong)(len), tokens, (ulong)(num_tokens)));
                if ((r) < (0))
                    return (int)(r);
                count++;
                if ((parser->toksuper != -1) && (tokens != null))
                    tokens[parser->toksuper].size++;
                break;
            case 9:
            case 13:
            case 10:
            case 32:
                break;
            case 58:
                parser->toksuper = (int)(parser->toknext - 1);
                break;
            case 44:
                if ((((tokens != null) && (parser->toksuper != -1)) && (tokens[parser->toksuper].type != jsmntype_t.JSMN_ARRAY)) && (tokens[parser->toksuper].type != jsmntype_t.JSMN_OBJECT))
                {
                    parser->toksuper = (int)(tokens[parser->toksuper].parent);
                }

                break;
            case 45:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 116:
            case 102:
            case 110:
                if ((tokens != null) && (parser->toksuper != -1))
                {
                    jsmntok_t* t = &tokens[parser->toksuper];
                    if (((t->type) == (jsmntype_t.JSMN_OBJECT)) || (((t->type) == (jsmntype_t.JSMN_STRING)) && (t->size != 0)))
                    {
                        return (int)(jsmnerr.JSMN_ERROR_INVAL);
                    }
                }

                r = (int)(jsmn_parse_primitive(parser, js, (ulong)(len), tokens, (ulong)(num_tokens)));
                if ((r) < (0))
                    return (int)(r);
                count++;
                if ((parser->toksuper != -1) && (tokens != null))
                    tokens[parser->toksuper].size++;
                break;
            default:
                return (int)(jsmnerr.JSMN_ERROR_INVAL);
        }
    }

    if (tokens != null)
    {
        for (i = (int)(parser->toknext - 1); (i) >= (0); i--)
        {
            if ((tokens[i].start != -1) && ((tokens[i].end) == (-1)))
            {
                return (int)(jsmnerr.JSMN_ERROR_PART);
            }
        }
    }

    return (int)(count);
}
public static void* cgltf_default_alloc(void* user, ulong size)
{
    return CRuntime.malloc((ulong)(size));
}
public static void cgltf_default_free(void* user, void* ptr)
{
    CRuntime.free(ptr);
}
public static void* cgltf_calloc(cgltf_options* options, ulong element_size, ulong count)
{
    if ((SIZE_MAX / element_size) < (count))
    {
        return null;
    }

    void* result = options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(element_size * count));
    if (result == null)
    {
        return null;
    }

    CRuntime.memset(result, (int)(0), (ulong)(element_size * count));
    return result;
}
public static void cgltf_default_file_release(cgltf_memory_options* memory_options, cgltf_file_options* file_options, void* data)
{
    delegate1 memfree = memory_options->free_func != IntPtr.Zero ? memory_options->GetFreeFunc() : cgltf_default_free;
    memfree(memory_options->user_data, data);
}
public static cgltf_result cgltf_parse_json(cgltf_options* options, byte* json_chunk, ulong size, cgltf_data** out_data)
{
    jsmn_parser parser = new();
    if ((options->json_token_count) == (0))
    {
        int token_count1 = (int)(jsmn_parse(&parser, (sbyte*)(json_chunk), (ulong)(size), null, (ulong)(0)));
        if ((token_count1) <= (0))
        {
            return (cgltf_result)(cgltf_result.cgltf_result_invalid_json);
        }

        options->json_token_count = (ulong)(token_count1);
    }

    jsmntok_t* tokens = (jsmntok_t*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)((ulong)sizeof(jsmntok_t) * (options->json_token_count + 1))));
    if (tokens == null)
    {
        return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
    }

    jsmn_init(&parser);
    int token_count = (int)(jsmn_parse(&parser, (sbyte*)(json_chunk), (ulong)(size), tokens, (ulong)(options->json_token_count)));
    if ((token_count) <= (0))
    {
        options->memory.GetFreeFunc()(options->memory.user_data, tokens);
        return (cgltf_result)(cgltf_result.cgltf_result_invalid_json);
    }

    tokens[token_count].type = (jsmntype_t)(jsmntype_t.JSMN_UNDEFINED);
    cgltf_data* data = (cgltf_data*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(sizeof(cgltf_data))));
    if (data == null)
    {
        options->memory.GetFreeFunc()(options->memory.user_data, tokens);
        return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
    }

    CRuntime.memset(data, (int)(0), (ulong)(sizeof(cgltf_data)));
    data->memory = (cgltf_memory_options)(options->memory);
    data->file = (cgltf_file_options)(options->file);
    int i = (int)(cgltf_parse_json_root(options, tokens, (int)(0), json_chunk, data));
    options->memory.GetFreeFunc()(options->memory.user_data, tokens);
    if ((i) < (0))
    {
        cgltf_free(data);
        switch (i)
        {
            case -2:
                return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
            case -3:
                return (cgltf_result)(cgltf_result.cgltf_result_legacy_gltf);
            default:
                return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
        }
    }

    if ((cgltf_fixup_pointers(data)) < (0))
    {
        cgltf_free(data);
        return (cgltf_result)(cgltf_result.cgltf_result_invalid_gltf);
    }

    data->json = (sbyte*)(json_chunk);
    data->json_size = (ulong)(size);
    *out_data = data;
    return (cgltf_result)(cgltf_result.cgltf_result_success);
}
public static void cgltf_combine_paths(sbyte* path, sbyte* _base_, sbyte* uri)
{
    sbyte* s0 = CRuntime.strrchr(_base_, (int)(47));
    sbyte* s1 = CRuntime.strrchr(_base_, (int)(92));
    sbyte* slash = (s0) != null ? (((s1) != null) && ((s1) > (s0)) ? s1 : s0) : s1;
    if ((slash) != null)
    {
        ulong prefix = (ulong)(slash - _base_ + 1);
        CRuntime.strncpy(path, _base_, (ulong)(prefix));
        CRuntime.strcpy(path + prefix, uri);
    }
    else
    {
        CRuntime.strcpy(path, uri);
    }
}
public static cgltf_result cgltf_load_buffer_file(cgltf_options* options, ulong size, sbyte* uri, sbyte* gltf_path, void** out_data)
{
    delegate0 memory_alloc = options->memory.alloc_func != IntPtr.Zero ? options->memory.GetAllocFunc() : cgltf_default_alloc;
    delegate1 memory_free = options->memory.free_func != IntPtr.Zero ? options->memory.GetFreeFunc() : cgltf_default_free;
    delegate2 file_read = options->file.read != IntPtr.Zero ? options->file.GetRead() : cgltf_default_file_read;
    sbyte* path = (sbyte*)(memory_alloc(options->memory.user_data, (ulong)(CRuntime.strlen(uri) + CRuntime.strlen(gltf_path) + 1)));
    if (path == null)
    {
        return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
    }

    cgltf_combine_paths(path, gltf_path, uri);
    cgltf_decode_uri(path + CRuntime.strlen(path) - CRuntime.strlen(uri));
    void* file_data = null;
    cgltf_result result = (cgltf_result)(file_read(&options->memory, &options->file, path, &size, &file_data));
    memory_free(options->memory.user_data, path);
    *out_data = ((result) == (cgltf_result.cgltf_result_success)) ? file_data : (null);
    return (cgltf_result)(result);
}
public static int cgltf_unhex(sbyte ch)
{
    return (int)(((uint)(ch - 48)) < (10) ? (ch - 48) : ((uint)(ch - 65)) < (6) ? (ch - 65) + 10 : ((uint)(ch - 97)) < (6) ? (ch - 97) + 10 : -1);
}
public static ulong cgltf_calc_index_bound(cgltf_buffer_view* buffer_view, ulong offset, cgltf_component_type component_type, ulong count)
{
    sbyte* data = (sbyte*)(buffer_view->buffer->data) + offset + buffer_view->offset;
    ulong bound = (ulong)(0);
    switch (component_type)
    {
        case cgltf_component_type.cgltf_component_type_r_8u:
            for (ulong i = (ulong)(0); (i) < (count); ++i)
            {
                ulong v = (ulong)(((byte*)(data))[i]);
                bound = (ulong)((bound) > (v) ? bound : v);
            }

            break;
        case cgltf_component_type.cgltf_component_type_r_16u:
            for (ulong i = (ulong)(0); (i) < (count); ++i)
            {
                ulong v = (ulong)(((ushort*)(data))[i]);
                bound = (ulong)((bound) > (v) ? bound : v);
            }

            break;
        case cgltf_component_type.cgltf_component_type_r_32u:
            for (ulong i = (ulong)(0); (i) < (count); ++i)
            {
                ulong v = (ulong)(((uint*)(data))[i]);
                bound = (ulong)((bound) > (v) ? bound : v);
            }

            break;
        default: break;
            ;
    }

    return (ulong)(bound);
}
public static void cgltf_free_extras(cgltf_data* data, cgltf_extras* extras)
{
    data->memory.GetFreeFunc()(data->memory.user_data, extras->data);
}
public static void cgltf_free_extensions(cgltf_data* data, cgltf_extension* extensions, ulong extensions_count)
{
    for (ulong i = (ulong)(0); (i) < (extensions_count); ++i)
    {
        data->memory.GetFreeFunc()(data->memory.user_data, extensions[i].name);
        data->memory.GetFreeFunc()(data->memory.user_data, extensions[i].data);
    }

    data->memory.GetFreeFunc()(data->memory.user_data, extensions);
}
public static long cgltf_component_read_integer(void* _in_, cgltf_component_type component_type)
{
    switch (component_type)
    {
        case cgltf_component_type.cgltf_component_type_r_16:
            return (long)(*((short*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_16u:
            return (long)(*((ushort*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_32u:
            return (long)(*((uint*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_8:
            return (long)(*((sbyte*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_8u:
            return (long)(*((byte*)(_in_)));
        default:
            return (long)(0);
    }
}
public static ulong cgltf_component_read_index(void* _in_, cgltf_component_type component_type)
{
    switch (component_type)
    {
        case cgltf_component_type.cgltf_component_type_r_16u:
            return (ulong)(*((ushort*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_32u:
            return (ulong)(*((uint*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_8u:
            return (ulong)(*((byte*)(_in_)));
        default:
            return (ulong)(0);
    }
}
public static float cgltf_component_read_float(void* _in_, cgltf_component_type component_type, int normalized)
{
    if ((component_type) == (cgltf_component_type.cgltf_component_type_r_32f))
    {
        return (float)(*((float*)(_in_)));
    }

    if ((normalized) != 0)
    {
        switch (component_type)
        {
            case cgltf_component_type.cgltf_component_type_r_16:
                return (float)(*((short*)(_in_)) / (float)(32767));
            case cgltf_component_type.cgltf_component_type_r_16u:
                return (float)(*((ushort*)(_in_)) / (float)(65535));
            case cgltf_component_type.cgltf_component_type_r_8:
                return (float)(*((sbyte*)(_in_)) / (float)(127));
            case cgltf_component_type.cgltf_component_type_r_8u:
                return (float)(*((byte*)(_in_)) / (float)(255));
            default:
                return (float)(0);
        }
    }

    return (float)(cgltf_component_read_integer(_in_, (cgltf_component_type)(component_type)));
}
public static int cgltf_element_read_float(byte* element, cgltf_type type, cgltf_component_type component_type, int normalized, float* _out_, ulong element_size)
{
    ulong num_components = (ulong)(cgltf_num_components((cgltf_type)(type)));
    if ((element_size) < (num_components))
    {
        return (int)(0);
    }

    ulong component_size = (ulong)(cgltf_component_size((cgltf_component_type)(component_type)));
    if (((type) == (cgltf_type.cgltf_type_mat2)) && ((component_size) == (1)))
    {
        _out_[0] = (float)(cgltf_component_read_float(element, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[1] = (float)(cgltf_component_read_float(element + 1, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[2] = (float)(cgltf_component_read_float(element + 4, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[3] = (float)(cgltf_component_read_float(element + 5, (cgltf_component_type)(component_type), (int)(normalized)));
        return (int)(1);
    }

    if (((type) == (cgltf_type.cgltf_type_mat3)) && ((component_size) == (1)))
    {
        _out_[0] = (float)(cgltf_component_read_float(element, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[1] = (float)(cgltf_component_read_float(element + 1, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[2] = (float)(cgltf_component_read_float(element + 2, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[3] = (float)(cgltf_component_read_float(element + 4, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[4] = (float)(cgltf_component_read_float(element + 5, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[5] = (float)(cgltf_component_read_float(element + 6, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[6] = (float)(cgltf_component_read_float(element + 8, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[7] = (float)(cgltf_component_read_float(element + 9, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[8] = (float)(cgltf_component_read_float(element + 10, (cgltf_component_type)(component_type), (int)(normalized)));
        return (int)(1);
    }

    if (((type) == (cgltf_type.cgltf_type_mat3)) && ((component_size) == (2)))
    {
        _out_[0] = (float)(cgltf_component_read_float(element, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[1] = (float)(cgltf_component_read_float(element + 2, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[2] = (float)(cgltf_component_read_float(element + 4, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[3] = (float)(cgltf_component_read_float(element + 8, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[4] = (float)(cgltf_component_read_float(element + 10, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[5] = (float)(cgltf_component_read_float(element + 12, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[6] = (float)(cgltf_component_read_float(element + 16, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[7] = (float)(cgltf_component_read_float(element + 18, (cgltf_component_type)(component_type), (int)(normalized)));
        _out_[8] = (float)(cgltf_component_read_float(element + 20, (cgltf_component_type)(component_type), (int)(normalized)));
        return (int)(1);
    }

    for (ulong i = (ulong)(0); (i) < (num_components); ++i)
    {
        _out_[i] = (float)(cgltf_component_read_float(element + component_size * i, (cgltf_component_type)(component_type), (int)(normalized)));
    }

    return (int)(1);
}
public static uint cgltf_component_read_uint(void* _in_, cgltf_component_type component_type)
{
    switch (component_type)
    {
        case cgltf_component_type.cgltf_component_type_r_8:
            return (uint)(*((sbyte*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_8u:
            return (uint)(*((byte*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_16:
            return (uint)(*((short*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_16u:
            return (uint)(*((ushort*)(_in_)));
        case cgltf_component_type.cgltf_component_type_r_32u:
            return (uint)(*((uint*)(_in_)));
        default:
            return (uint)(0);
    }
}
public static int cgltf_element_read_uint(byte* element, cgltf_type type, cgltf_component_type component_type, uint* _out_, ulong element_size)
{
    ulong num_components = (ulong)(cgltf_num_components((cgltf_type)(type)));
    if ((element_size) < (num_components))
    {
        return (int)(0);
    }

    if ((((type) == (cgltf_type.cgltf_type_mat2)) || ((type) == (cgltf_type.cgltf_type_mat3))) || ((type) == (cgltf_type.cgltf_type_mat4)))
    {
        return (int)(0);
    }

    ulong component_size = (ulong)(cgltf_component_size((cgltf_component_type)(component_type)));
    for (ulong i = (ulong)(0); (i) < (num_components); ++i)
    {
        _out_[i] = (uint)(cgltf_component_read_uint(element + component_size * i, (cgltf_component_type)(component_type)));
    }

    return (int)(1);
}
public static int cgltf_json_strcmp(jsmntok_t* tok, byte* json_chunk, sbyte[] str)
{
    if ((*tok).type != (jsmntype_t.JSMN_STRING))
    {
        return (int)(-1);
    }

    ulong str_len = (ulong)(CRuntime.strlen(str));
    ulong name_length = (ulong)(tok->end - tok->start);
    return (int)(((str_len) == (name_length)) ? CRuntime.strncmp((sbyte*)(json_chunk) + tok->start, str, (ulong)(str_len)) : 128);
}
public static int cgltf_json_to_int(jsmntok_t* tok, byte* json_chunk)
{
    if ((*tok).type != (jsmntype_t.JSMN_PRIMITIVE))
    {
        return (int)(-1);
    }

    sbyte* tmp = stackalloc sbyte[128];
    int size = (int)(((ulong)(tok->end - tok->start)) < (128 * sizeof(sbyte)) ? (int)(tok->end - tok->start) : (int)(128 * sizeof(sbyte) - 1));
    CRuntime.strncpy(tmp, (sbyte*)(json_chunk) + tok->start, (ulong)(size));
    tmp[size] = (sbyte)(0);
    return (int)(CRuntime.atoi(tmp));
}
public static ulong cgltf_json_to_size(jsmntok_t* tok, byte* json_chunk)
{
    if ((*tok).type != (jsmntype_t.JSMN_PRIMITIVE))
    {
        return (ulong)(0);
    }

    sbyte* tmp = stackalloc sbyte[128];
    int size = (int)(((ulong)(tok->end - tok->start)) < (128 * sizeof(sbyte)) ? (int)(tok->end - tok->start) : (int)(128 * sizeof(sbyte) - 1));
    CRuntime.strncpy(tmp, (sbyte*)(json_chunk) + tok->start, (ulong)(size));
    tmp[size] = (sbyte)(0);
    long res = (long)(CRuntime.atoll(tmp));
    return (ulong)((res) < (0) ? 0 : (ulong)(res));
}
public static float cgltf_json_to_float(jsmntok_t* tok, byte* json_chunk)
{
    if ((*tok).type != (jsmntype_t.JSMN_PRIMITIVE))
    {
        return (float)(-1);
    }

    sbyte* tmp = stackalloc sbyte[128];
    int size = (int)(((ulong)(tok->end - tok->start)) < (128 * sizeof(sbyte)) ? (int)(tok->end - tok->start) : (int)(128 * sizeof(sbyte) - 1));
    CRuntime.strncpy(tmp, (sbyte*)(json_chunk) + tok->start, (ulong)(size));
    tmp[size] = (sbyte)(0);
    return (float)(CRuntime.atof(tmp));
}
public static int cgltf_json_to_bool(jsmntok_t* tok, byte* json_chunk)
{
    int size = (int)(tok->end - tok->start);
    return (((size) == (4)) && ((CRuntime.memcmp(json_chunk + tok->start, const_true, (ulong)(4))) == (0)) ? 1 : 0);
}
public static int cgltf_skip_json(jsmntok_t* tokens, int i)
{
    int end = (int)(i + 1);
    while ((i) < (end))
    {
        switch (tokens[i].type)
        {
            case jsmntype_t.JSMN_OBJECT:
                end += (int)(tokens[i].size * 2);
                break;
            case jsmntype_t.JSMN_ARRAY:
                end += (int)(tokens[i].size);
                break;
            case jsmntype_t.JSMN_PRIMITIVE:
            case jsmntype_t.JSMN_STRING:
                break;
            default:
                return (int)(-1);
        }

        i++;
    }

    return (int)(i);
}
public static void cgltf_fill_float_array(float* out_array, int size, float value)
{
    for (int j = (int)(0); (j) < (size); ++j)
    {
        out_array[j] = (float)(value);
    }
}
public static int cgltf_parse_json_float_array(jsmntok_t* tokens, int i, byte* json_chunk, float* out_array, int size)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_ARRAY))
    {
        return (int)(-1);
    }

    if (tokens[i].size != size)
    {
        return (int)(-1);
    }

    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
        {
            return (int)(-1);
        }

        out_array[j] = (float)(cgltf_json_to_float(tokens + i, json_chunk));
        ++i;
    }

    return (int)(i);
}
public static int cgltf_parse_json_string(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, sbyte** out_string)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_STRING))
    {
        return (int)(-1);
    }

    if ((*out_string) != null)
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].end - tokens[i].start);
    sbyte* result = (sbyte*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(size + 1)));
    if (result == null)
    {
        return (int)(-2);
    }

    CRuntime.strncpy(result, (sbyte*)(json_chunk) + tokens[i].start, (ulong)(size));
    result[size] = (sbyte)(0);
    *out_string = result;
    return (int)(i + 1);
}
public static int cgltf_parse_json_array(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, ulong element_size, void** out_array, ulong* out_size)
{
    if (tokens[i].type != jsmntype_t.JSMN_ARRAY)
    {
        return (int)((tokens[i].type) == (jsmntype_t.JSMN_OBJECT) ? -3 : -1);
    }

    if ((*out_array) != null)
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    void* result = cgltf_calloc(options, (ulong)(element_size), (ulong)(size));
    if (result == null)
    {
        return (int)(-2);
    }

    *out_array = result;
    *out_size = (ulong)(size);
    return (int)(i + 1);
}
public static int cgltf_parse_json_string_array(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, sbyte*** out_array, ulong* out_size)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_ARRAY))
    {
        return (int)(-1);
    }

    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(char*)), (void**)(out_array), out_size));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (*out_size); ++j)
    {
        i = (int)(cgltf_parse_json_string(options, tokens, (int)(i), json_chunk, j + (*out_array)));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static void cgltf_parse_attribute_type(sbyte* name, cgltf_attribute_type* out_type, int* out_index)
{
    if ((*name) == (95))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_custom);
        return;
    }

    sbyte* us = CRuntime.strchr(name, (int)(95));
    ulong len = (ulong)((us) != null ? (ulong)(us - name) : CRuntime.strlen(name));
    if (((len) == (8)) && ((CRuntime.strncmp(name, const_POSITION, (ulong)(8))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_position);
    }
    else if (((len) == (6)) && ((CRuntime.strncmp(name, const_NORMAL, (ulong)(6))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_normal);
    }
    else if (((len) == (7)) && ((CRuntime.strncmp(name, const_TANGENT, (ulong)(7))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_tangent);
    }
    else if (((len) == (8)) && ((CRuntime.strncmp(name, const_TEXCOORD, (ulong)(8))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_texcoord);
    }
    else if (((len) == (5)) && ((CRuntime.strncmp(name, const_COLOR, (ulong)(5))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_color);
    }
    else if (((len) == (6)) && ((CRuntime.strncmp(name, const_JOINTS, (ulong)(6))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_joints);
    }
    else if (((len) == (7)) && ((CRuntime.strncmp(name, const_WEIGHTS, (ulong)(7))) == (0)))
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_weights);
    }
    else
    {
        *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_invalid);
    }

    if (((us) != null) && (*out_type != cgltf_attribute_type.cgltf_attribute_type_invalid))
    {
        *out_index = (int)(CRuntime.atoi(us + 1));
        if ((*out_index) < (0))
        {
            *out_type = (cgltf_attribute_type)(cgltf_attribute_type.cgltf_attribute_type_invalid);
            *out_index = (int)(0);
        }
    }
}
public static int cgltf_parse_json_attribute_list(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_attribute** out_attributes, ulong* out_attributes_count)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    if ((*out_attributes) != null)
    {
        return (int)(-1);
    }

    *out_attributes_count = (ulong)(tokens[i].size);
    *out_attributes = (cgltf_attribute*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_attribute)), (ulong)(*out_attributes_count)));
    ++i;
    if (*out_attributes == null)
    {
        return (int)(-2);
    }

    for (ulong j = (ulong)(0); (j) < (*out_attributes_count); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        i = (int)(cgltf_parse_json_string(options, tokens, (int)(i), json_chunk, &(*out_attributes)[j].name));
        if ((i) < (0))
        {
            return (int)(-1);
        }

        cgltf_parse_attribute_type((*out_attributes)[j].name, &(*out_attributes)[j].type, &(*out_attributes)[j].index);
        (*out_attributes)[j].data = (cgltf_accessor*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
        ++i;
    }

    return (int)(i);
}
public static int cgltf_parse_json_extras(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_extras* out_extras)
{
    if ((out_extras->data) != null)
    {
        return (int)(-1);
    }

    out_extras->start_offset = (ulong)(tokens[i].start);
    out_extras->end_offset = (ulong)(tokens[i].end);
    ulong start = (ulong)(tokens[i].start);
    ulong size = (ulong)((ulong)tokens[i].end - start);
    out_extras->data = (sbyte*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(size + 1)));
    if (out_extras->data == null)
    {
        return (int)(-2);
    }

    CRuntime.strncpy(out_extras->data, (sbyte*)(json_chunk) + start, (ulong)(size));
    out_extras->data[size] = (sbyte)(0);
    i = (int)(cgltf_skip_json(tokens, (int)(i)));
    return (int)(i);
}
public static int cgltf_parse_json_unprocessed_extension(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_extension* out_extension)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_STRING))
    {
        return (int)(-1);
    }

    if ((tokens[i + 1]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    if ((out_extension->name) != null)
    {
        return (int)(-1);
    }

    ulong name_length = (ulong)(tokens[i].end - tokens[i].start);
    out_extension->name = (sbyte*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(name_length + 1)));
    if (out_extension->name == null)
    {
        return (int)(-2);
    }

    CRuntime.strncpy(out_extension->name, (sbyte*)(json_chunk) + tokens[i].start, (ulong)(name_length));
    out_extension->name[name_length] = (sbyte)(0);
    i++;
    ulong start = (ulong)(tokens[i].start);
    ulong size = (ulong)((ulong)tokens[i].end - start);
    out_extension->data = (sbyte*)(options->memory.GetAllocFunc()(options->memory.user_data, (ulong)(size + 1)));
    if (out_extension->data == null)
    {
        return (int)(-2);
    }

    CRuntime.strncpy(out_extension->data, (sbyte*)(json_chunk) + start, (ulong)(size));
    out_extension->data[size] = (sbyte)(0);
    i = (int)(cgltf_skip_json(tokens, (int)(i)));
    return (int)(i);
}
public static int cgltf_parse_json_unprocessed_extensions(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, ulong* out_extensions_count, cgltf_extension** out_extensions)
{
    ++i;
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    if ((*out_extensions) != null)
    {
        return (int)(-1);
    }

    int extensions_size = (int)(tokens[i].size);
    *out_extensions_count = (ulong)(0);
    *out_extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
    if (*out_extensions == null)
    {
        return (int)(-2);
    }

    ++i;
    for (int j = (int)(0); (j) < (extensions_size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        ulong extension_index = (ulong)((*out_extensions_count)++);
        cgltf_extension* extension = &((*out_extensions)[extension_index]);
        i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, extension));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_draco_mesh_compression(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_draco_mesh_compression* out_draco_mesh_compression)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_attributes)) == (0))
        {
            i = (int)(cgltf_parse_json_attribute_list(options, tokens, (int)(i + 1), json_chunk, &out_draco_mesh_compression->attributes, &out_draco_mesh_compression->attributes_count));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferView)) == (0))
        {
            ++i;
            out_draco_mesh_compression->buffer_view = (cgltf_buffer_view*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_mesh_gpu_instancing(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_mesh_gpu_instancing* out_mesh_gpu_instancing)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_attributes)) == (0))
        {
            i = (int)(cgltf_parse_json_attribute_list(options, tokens, (int)(i + 1), json_chunk, &out_mesh_gpu_instancing->attributes, &out_mesh_gpu_instancing->attributes_count));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_material_mapping_data(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_material_mapping* out_mappings, ulong* offset)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_ARRAY))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
        {
            return (int)(-1);
        }

        int obj_size = (int)(tokens[i].size);
        ++i;
        int material = (int)(-1);
        int variants_tok = (int)(-1);
        int extras_tok = (int)(-1);
        for (int k = (int)(0); (k) < (obj_size); ++k)
        {
            if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
            {
                return (int)(-1);
            }

            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_material)) == (0))
            {
                ++i;
                material = (int)(cgltf_json_to_int(tokens + i, json_chunk));
                ++i;
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_variants)) == (0))
            {
                variants_tok = (int)(i + 1);
                if ((tokens[variants_tok]).type != (jsmntype_t.JSMN_ARRAY))
                {
                    return (int)(-1);
                }

                i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
            {
                extras_tok = (int)(i + 1);
                i = (int)(cgltf_skip_json(tokens, (int)(extras_tok)));
            }
            else
            {
                i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
            }

            if ((i) < (0))
            {
                return (int)(i);
            }
        }

        if (((material) < (0)) || ((variants_tok) < (0)))
        {
            return (int)(-1);
        }

        if ((out_mappings) != null)
        {
            for (int k = (int)(0); (k) < (tokens[variants_tok].size); ++k)
            {
                int variant = (int)(cgltf_json_to_int(&tokens[variants_tok + 1 + k], json_chunk));
                if ((variant) < (0))
                    return (int)(variant);
                out_mappings[*offset].material = (cgltf_material*)((ulong)(material) + 1);
                out_mappings[*offset].variant = (ulong)(variant);
                if ((extras_tok) >= (0))
                {
                    int e = (int)(cgltf_parse_json_extras(options, tokens, (int)(extras_tok), json_chunk, &out_mappings[*offset].extras));
                    if ((e) < (0))
                        return (int)(e);
                }

                (*offset)++;
            }
        }
        else
        {
            (*offset) += (ulong)(tokens[variants_tok].size);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_material_mappings(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_primitive* out_prim)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_mappings)) == (0))
        {
            if ((out_prim->mappings) != null)
            {
                return (int)(-1);
            }

            ulong mappings_offset = (ulong)(0);
            int k = (int)(cgltf_parse_json_material_mapping_data(options, tokens, (int)(i + 1), json_chunk, null, &mappings_offset));
            if ((k) < (0))
            {
                return (int)(k);
            }

            out_prim->mappings_count = (ulong)(mappings_offset);
            out_prim->mappings = (cgltf_material_mapping*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_material_mapping)), (ulong)(out_prim->mappings_count)));
            mappings_offset = (ulong)(0);
            i = (int)(cgltf_parse_json_material_mapping_data(options, tokens, (int)(i + 1), json_chunk, out_prim->mappings, &mappings_offset));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static cgltf_primitive_type cgltf_json_to_primitive_type(jsmntok_t* tok, byte* json_chunk)
{
    int type = (int)(cgltf_json_to_int(tok, json_chunk));
    switch (type)
    {
        case 0:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_points);
        case 1:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_lines);
        case 2:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_line_loop);
        case 3:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_line_strip);
        case 4:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_triangles);
        case 5:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_triangle_strip);
        case 6:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_triangle_fan);
        default:
            return (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_invalid);
    }
}
public static int cgltf_parse_json_primitive(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_primitive* out_prim)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    out_prim->type = (cgltf_primitive_type)(cgltf_primitive_type.cgltf_primitive_type_triangles);
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_mode)) == (0))
        {
            ++i;
            out_prim->type = (cgltf_primitive_type)(cgltf_json_to_primitive_type(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_indices)) == (0))
        {
            ++i;
            out_prim->indices = (cgltf_accessor*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_material)) == (0))
        {
            ++i;
            out_prim->material = (cgltf_material*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_attributes)) == (0))
        {
            i = (int)(cgltf_parse_json_attribute_list(options, tokens, (int)(i + 1), json_chunk, &out_prim->attributes, &out_prim->attributes_count));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_targets)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_morph_target)), (void**)(&out_prim->targets), &out_prim->targets_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_prim->targets_count); ++k)
            {
                i = (int)(cgltf_parse_json_attribute_list(options, tokens, (int)(i), json_chunk, &out_prim->targets[k].attributes, &out_prim->targets[k].attributes_count));
                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_prim->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_prim->extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            out_prim->extensions_count = (ulong)(0);
            out_prim->extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            if (out_prim->extensions == null)
            {
                return (int)(-2);
            }

            ++i;
            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_draco_mesh_compression)) == (0))
                {
                    out_prim->has_draco_mesh_compression = (int)(1);
                    i = (int)(cgltf_parse_json_draco_mesh_compression(options, tokens, (int)(i + 1), json_chunk, &out_prim->draco_mesh_compression));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_variants)) == (0))
                {
                    i = (int)(cgltf_parse_json_material_mappings(options, tokens, (int)(i + 1), json_chunk, out_prim));
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_prim->extensions[out_prim->extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_mesh(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_mesh* out_mesh)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_mesh->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_primitives)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_primitive)), (void**)(&out_mesh->primitives), &out_mesh->primitives_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong prim_index = (ulong)(0); (prim_index) < (out_mesh->primitives_count); ++prim_index)
            {
                i = (int)(cgltf_parse_json_primitive(options, tokens, (int)(i), json_chunk, &out_mesh->primitives[prim_index]));
                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_weights)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(float)), (void**)(&out_mesh->weights), &out_mesh->weights_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i - 1), json_chunk, out_mesh->weights, (int)(out_mesh->weights_count)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            ++i;
            out_mesh->extras.start_offset = (ulong)(tokens[i].start);
            out_mesh->extras.end_offset = (ulong)(tokens[i].end);
            if ((tokens[i].type) == (jsmntype_t.JSMN_OBJECT))
            {
                int extras_size = (int)(tokens[i].size);
                ++i;
                for (int k = (int)(0); (k) < (extras_size); ++k)
                {
                    if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                    {
                        return (int)(-1);
                    }

                    if (((cgltf_json_strcmp(tokens + i, json_chunk, const_targetNames)) == (0)) && ((tokens[i + 1].type) == (jsmntype_t.JSMN_ARRAY)))
                    {
                        i = (int)(cgltf_parse_json_string_array(options, tokens, (int)(i + 1), json_chunk, &out_mesh->target_names, &out_mesh->target_names_count));
                    }
                    else
                    {
                        i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                    }

                    if ((i) < (0))
                    {
                        return (int)(i);
                    }
                }
            }
            else
            {
                i = (int)(cgltf_skip_json(tokens, (int)(i)));
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_mesh->extensions_count, &out_mesh->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_meshes(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_mesh)), (void**)(&out_data->meshes), &out_data->meshes_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->meshes_count); ++j)
    {
        i = (int)(cgltf_parse_json_mesh(options, tokens, (int)(i), json_chunk, &out_data->meshes[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static cgltf_component_type cgltf_json_to_component_type(jsmntok_t* tok, byte* json_chunk)
{
    int type = (int)(cgltf_json_to_int(tok, json_chunk));
    switch (type)
    {
        case 5120:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_8);
        case 5121:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_8u);
        case 5122:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_16);
        case 5123:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_16u);
        case 5125:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_32u);
        case 5126:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_r_32f);
        default:
            return (cgltf_component_type)(cgltf_component_type.cgltf_component_type_invalid);
    }
}
public static int cgltf_parse_json_accessor_sparse(jsmntok_t* tokens, int i, byte* json_chunk, cgltf_accessor_sparse* out_sparse)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_count)) == (0))
        {
            ++i;
            out_sparse->count = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_indices)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int indices_size = (int)(tokens[i].size);
            ++i;
            for (int k = (int)(0); (k) < (indices_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferView)) == (0))
                {
                    ++i;
                    out_sparse->indices_buffer_view = (cgltf_buffer_view*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteOffset)) == (0))
                {
                    ++i;
                    out_sparse->indices_byte_offset = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_componentType)) == (0))
                {
                    ++i;
                    out_sparse->indices_component_type = (cgltf_component_type)(cgltf_json_to_component_type(tokens + i, json_chunk));
                    ++i;
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_values)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int values_size = (int)(tokens[i].size);
            ++i;
            for (int k = (int)(0); (k) < (values_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferView)) == (0))
                {
                    ++i;
                    out_sparse->values_buffer_view = (cgltf_buffer_view*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteOffset)) == (0))
                {
                    ++i;
                    out_sparse->values_byte_offset = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
                    ++i;
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_accessor(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_accessor* out_accessor)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_accessor->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferView)) == (0))
        {
            ++i;
            out_accessor->buffer_view = (cgltf_buffer_view*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteOffset)) == (0))
        {
            ++i;
            out_accessor->offset = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_componentType)) == (0))
        {
            ++i;
            out_accessor->component_type = (cgltf_component_type)(cgltf_json_to_component_type(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_normalized)) == (0))
        {
            ++i;
            out_accessor->normalized = (int)(cgltf_json_to_bool(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_count)) == (0))
        {
            ++i;
            out_accessor->count = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_type)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_SCALAR)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_scalar);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_35)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_vec2);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_36)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_vec3);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_37)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_vec4);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_38)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_mat2);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_39)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_mat3);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_40)) == (0))
            {
                out_accessor->type = (cgltf_type)(cgltf_type.cgltf_type_mat4);
            }

            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_min)) == (0))
        {
            ++i;
            out_accessor->has_min = (int)(1);
            int min_size = (int)((tokens[i].size) > (16) ? 16 : tokens[i].size);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i), json_chunk, out_accessor->min, (int)(min_size)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_max)) == (0))
        {
            ++i;
            out_accessor->has_max = (int)(1);
            int max_size = (int)((tokens[i].size) > (16) ? 16 : tokens[i].size);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i), json_chunk, out_accessor->max, (int)(max_size)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sparse)) == (0))
        {
            out_accessor->is_sparse = (int)(1);
            i = (int)(cgltf_parse_json_accessor_sparse(tokens, (int)(i + 1), json_chunk, &out_accessor->sparse));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_accessor->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_accessor->extensions_count, &out_accessor->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_texture_transform(jsmntok_t* tokens, int i, byte* json_chunk, cgltf_texture_transform* out_texture_transform)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_offset)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_texture_transform->offset, (int)(2)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_rotation)) == (0))
        {
            ++i;
            out_texture_transform->rotation = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scale)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_texture_transform->scale, (int)(2)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_texCoord)) == (0))
        {
            ++i;
            out_texture_transform->has_texcoord = (int)(1);
            out_texture_transform->texcoord = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_texture_view(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_texture_view* out_texture_view)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    out_texture_view->scale = (float)(1.0f);
    cgltf_fill_float_array(out_texture_view->transform.scale, (int)(2), (float)(1.0f));
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_index)) == (0))
        {
            ++i;
            out_texture_view->texture = (cgltf_texture*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_texCoord)) == (0))
        {
            ++i;
            out_texture_view->texcoord = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scale)) == (0))
        {
            ++i;
            out_texture_view->scale = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_strength)) == (0))
        {
            ++i;
            out_texture_view->scale = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            ++i;
            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_texture_transform)) == (0))
                {
                    out_texture_view->has_transform = (int)(1);
                    i = (int)(cgltf_parse_json_texture_transform(tokens, (int)(i + 1), json_chunk, &out_texture_view->transform));
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_pbr_metallic_roughness(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_pbr_metallic_roughness* out_pbr)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_metallicFactor)) == (0))
        {
            ++i;
            out_pbr->metallic_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_roughnessFactor)) == (0))
        {
            ++i;
            out_pbr->roughness_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_baseColorFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_pbr->base_color_factor, (int)(4)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_baseColorTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_pbr->base_color_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_metallicRoughnessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_pbr->metallic_roughness_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_pbr_specular_glossiness(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_pbr_specular_glossiness* out_pbr)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_pbr->diffuse_factor, (int)(4)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_pbr->specular_factor, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_glossinessFactor)) == (0))
        {
            ++i;
            out_pbr->glossiness_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_pbr->diffuse_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularGlossinessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_pbr->specular_glossiness_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_clearcoat(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_clearcoat* out_clearcoat)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_clearcoatFactor)) == (0))
        {
            ++i;
            out_clearcoat->clearcoat_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_clearcoatRoughnessFactor)) == (0))
        {
            ++i;
            out_clearcoat->clearcoat_roughness_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_clearcoatTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_clearcoat->clearcoat_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_clearcoatRoughnessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_clearcoat->clearcoat_roughness_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_clearcoatNormalTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_clearcoat->clearcoat_normal_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_ior(jsmntok_t* tokens, int i, byte* json_chunk, cgltf_ior* out_ior)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    out_ior->ior = (float)(1.5f);
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_ior)) == (0))
        {
            ++i;
            out_ior->ior = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_specular(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_specular* out_specular)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    out_specular->specular_factor = (float)(1.0f);
    cgltf_fill_float_array(out_specular->specular_color_factor, (int)(3), (float)(1.0f));
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularFactor)) == (0))
        {
            ++i;
            out_specular->specular_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularColorFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_specular->specular_color_factor, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_specular->specular_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_specularColorTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_specular->specular_color_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_transmission(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_transmission* out_transmission)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_transmissionFactor)) == (0))
        {
            ++i;
            out_transmission->transmission_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_transmissionTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_transmission->transmission_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_volume(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_volume* out_volume)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_thicknessFactor)) == (0))
        {
            ++i;
            out_volume->thickness_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_thicknessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_volume->thickness_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_attenuationColor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_volume->attenuation_color, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_attenuationDistance)) == (0))
        {
            ++i;
            out_volume->attenuation_distance = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_sheen(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_sheen* out_sheen)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sheenColorFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_sheen->sheen_color_factor, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sheenColorTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_sheen->sheen_color_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sheenRoughnessFactor)) == (0))
        {
            ++i;
            out_sheen->sheen_roughness_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sheenRoughnessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_sheen->sheen_roughness_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_emissive_strength(jsmntok_t* tokens, int i, byte* json_chunk, cgltf_emissive_strength* out_emissive_strength)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    out_emissive_strength->emissive_strength = (float)(1.0f);
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_emissiveStrength)) == (0))
        {
            ++i;
            out_emissive_strength->emissive_strength = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_iridescence(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_iridescence* out_iridescence)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    out_iridescence->iridescence_ior = (float)(1.3f);
    out_iridescence->iridescence_thickness_min = (float)(100.0f);
    out_iridescence->iridescence_thickness_max = (float)(400.0f);
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceFactor)) == (0))
        {
            ++i;
            out_iridescence->iridescence_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_iridescence->iridescence_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceIor)) == (0))
        {
            ++i;
            out_iridescence->iridescence_ior = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceThicknessMinimum)) == (0))
        {
            ++i;
            out_iridescence->iridescence_thickness_min = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceThicknessMaximum)) == (0))
        {
            ++i;
            out_iridescence->iridescence_thickness_max = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_iridescenceThicknessTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_iridescence->iridescence_thickness_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_diffuse_transmission(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_diffuse_transmission* out_diff_transmission)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    cgltf_fill_float_array(out_diff_transmission->diffuse_transmission_color_factor, (int)(3), (float)(1.0f));
    out_diff_transmission->diffuse_transmission_factor = (float)(0.0f);
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseTransmissionFactor)) == (0))
        {
            ++i;
            out_diff_transmission->diffuse_transmission_factor = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseTransmissionTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_diff_transmission->diffuse_transmission_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseTransmissionColorFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_diff_transmission->diffuse_transmission_color_factor, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_diffuseTransmissionColorTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_diff_transmission->diffuse_transmission_color_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_anisotropy(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_anisotropy* out_anisotropy)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_anisotropyStrength)) == (0))
        {
            ++i;
            out_anisotropy->anisotropy_strength = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_anisotropyRotation)) == (0))
        {
            ++i;
            out_anisotropy->anisotropy_rotation = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_anisotropyTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_anisotropy->anisotropy_texture));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_dispersion(jsmntok_t* tokens, int i, byte* json_chunk, cgltf_dispersion* out_dispersion)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_dispersion)) == (0))
        {
            ++i;
            out_dispersion->dispersion = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_image(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_image* out_image)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_uri)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_image->uri));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferView)) == (0))
        {
            ++i;
            out_image->buffer_view = (cgltf_buffer_view*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_mimeType)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_image->mime_type));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_image->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_image->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_image->extensions_count, &out_image->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_sampler(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_sampler* out_sampler)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    out_sampler->wrap_s = (int)(10497);
    out_sampler->wrap_t = (int)(10497);
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_sampler->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_magFilter)) == (0))
        {
            ++i;
            out_sampler->mag_filter = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_minFilter)) == (0))
        {
            ++i;
            out_sampler->min_filter = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_wrapS)) == (0))
        {
            ++i;
            out_sampler->wrap_s = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_wrapT)) == (0))
        {
            ++i;
            out_sampler->wrap_t = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_sampler->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_sampler->extensions_count, &out_sampler->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_texture(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_texture* out_texture)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_texture->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sampler)) == (0))
        {
            ++i;
            out_texture->sampler = (cgltf_sampler*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_source)) == (0))
        {
            ++i;
            out_texture->image = (cgltf_image*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_texture->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_texture->extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            ++i;
            out_texture->extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            out_texture->extensions_count = (ulong)(0);
            if (out_texture->extensions == null)
            {
                return (int)(-2);
            }

            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_texture_basisu)) == (0))
                {
                    out_texture->has_basisu = (int)(1);
                    ++i;
                    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
                    {
                        return (int)(-1);
                    }

                    int num_properties = (int)(tokens[i].size);
                    ++i;
                    for (int t = (int)(0); (t) < (num_properties); ++t)
                    {
                        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                        {
                            return (int)(-1);
                        }

                        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_source)) == (0))
                        {
                            ++i;
                            out_texture->basisu_image = (cgltf_image*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                            ++i;
                        }
                        else
                        {
                            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                        }

                        if ((i) < (0))
                        {
                            return (int)(i);
                        }
                    }
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_EXT_texture_webp)) == (0))
                {
                    out_texture->has_webp = (int)(1);
                    ++i;
                    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
                    {
                        return (int)(-1);
                    }

                    int num_properties = (int)(tokens[i].size);
                    ++i;
                    for (int t = (int)(0); (t) < (num_properties); ++t)
                    {
                        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                        {
                            return (int)(-1);
                        }

                        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_source)) == (0))
                        {
                            ++i;
                            out_texture->webp_image = (cgltf_image*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                            ++i;
                        }
                        else
                        {
                            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                        }

                        if ((i) < (0))
                        {
                            return (int)(i);
                        }
                    }
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_texture->extensions[out_texture->extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_material(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_material* out_material)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    cgltf_fill_float_array(out_material->pbr_metallic_roughness.base_color_factor, (int)(4), (float)(1.0f));
    out_material->pbr_metallic_roughness.metallic_factor = (float)(1.0f);
    out_material->pbr_metallic_roughness.roughness_factor = (float)(1.0f);
    cgltf_fill_float_array(out_material->pbr_specular_glossiness.diffuse_factor, (int)(4), (float)(1.0f));
    cgltf_fill_float_array(out_material->pbr_specular_glossiness.specular_factor, (int)(3), (float)(1.0f));
    out_material->pbr_specular_glossiness.glossiness_factor = (float)(1.0f);
    cgltf_fill_float_array(out_material->volume.attenuation_color, (int)(3), (float)(1.0f));
    out_material->volume.attenuation_distance = (float)(0);
    out_material->alpha_cutoff = (float)(0.5f);
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_material->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_pbrMetallicRoughness)) == (0))
        {
            out_material->has_pbr_metallic_roughness = (int)(1);
            i = (int)(cgltf_parse_json_pbr_metallic_roughness(options, tokens, (int)(i + 1), json_chunk, &out_material->pbr_metallic_roughness));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_emissiveFactor)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_material->emissive_factor, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_normalTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_material->normal_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_occlusionTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_material->occlusion_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_emissiveTexture)) == (0))
        {
            i = (int)(cgltf_parse_json_texture_view(options, tokens, (int)(i + 1), json_chunk, &out_material->emissive_texture));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_alphaMode)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_OPAQUE)) == (0))
            {
                out_material->alpha_mode = (cgltf_alpha_mode)(cgltf_alpha_mode.cgltf_alpha_mode_opaque);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_MASK)) == (0))
            {
                out_material->alpha_mode = (cgltf_alpha_mode)(cgltf_alpha_mode.cgltf_alpha_mode_mask);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_BLEND)) == (0))
            {
                out_material->alpha_mode = (cgltf_alpha_mode)(cgltf_alpha_mode.cgltf_alpha_mode_blend);
            }

            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_alphaCutoff)) == (0))
        {
            ++i;
            out_material->alpha_cutoff = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_doubleSided)) == (0))
        {
            ++i;
            out_material->double_sided = (int)(cgltf_json_to_bool(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_material->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_material->extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            ++i;
            out_material->extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            out_material->extensions_count = (ulong)(0);
            if (out_material->extensions == null)
            {
                return (int)(-2);
            }

            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_pbrSpecularGlossiness)) == (0))
                {
                    out_material->has_pbr_specular_glossiness = (int)(1);
                    i = (int)(cgltf_parse_json_pbr_specular_glossiness(options, tokens, (int)(i + 1), json_chunk, &out_material->pbr_specular_glossiness));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_unlit)) == (0))
                {
                    out_material->unlit = (int)(1);
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_clearcoat)) == (0))
                {
                    out_material->has_clearcoat = (int)(1);
                    i = (int)(cgltf_parse_json_clearcoat(options, tokens, (int)(i + 1), json_chunk, &out_material->clearcoat));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_ior)) == (0))
                {
                    out_material->has_ior = (int)(1);
                    i = (int)(cgltf_parse_json_ior(tokens, (int)(i + 1), json_chunk, &out_material->ior));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_specular)) == (0))
                {
                    out_material->has_specular = (int)(1);
                    i = (int)(cgltf_parse_json_specular(options, tokens, (int)(i + 1), json_chunk, &out_material->specular));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_transmission)) == (0))
                {
                    out_material->has_transmission = (int)(1);
                    i = (int)(cgltf_parse_json_transmission(options, tokens, (int)(i + 1), json_chunk, &out_material->transmission));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_volume)) == (0))
                {
                    out_material->has_volume = (int)(1);
                    i = (int)(cgltf_parse_json_volume(options, tokens, (int)(i + 1), json_chunk, &out_material->volume));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_sheen)) == (0))
                {
                    out_material->has_sheen = (int)(1);
                    i = (int)(cgltf_parse_json_sheen(options, tokens, (int)(i + 1), json_chunk, &out_material->sheen));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_emissive_strength)) == (0))
                {
                    out_material->has_emissive_strength = (int)(1);
                    i = (int)(cgltf_parse_json_emissive_strength(tokens, (int)(i + 1), json_chunk, &out_material->emissive_strength));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_iridescence)) == (0))
                {
                    out_material->has_iridescence = (int)(1);
                    i = (int)(cgltf_parse_json_iridescence(options, tokens, (int)(i + 1), json_chunk, &out_material->iridescence));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_diffuse_transmission)) == (0))
                {
                    out_material->has_diffuse_transmission = (int)(1);
                    i = (int)(cgltf_parse_json_diffuse_transmission(options, tokens, (int)(i + 1), json_chunk, &out_material->diffuse_transmission));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_anisotropy)) == (0))
                {
                    out_material->has_anisotropy = (int)(1);
                    i = (int)(cgltf_parse_json_anisotropy(options, tokens, (int)(i + 1), json_chunk, &out_material->anisotropy));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_dispersion)) == (0))
                {
                    out_material->has_dispersion = (int)(1);
                    i = (int)(cgltf_parse_json_dispersion(tokens, (int)(i + 1), json_chunk, &out_material->dispersion));
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_material->extensions[out_material->extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_accessors(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_accessor)), (void**)(&out_data->accessors), &out_data->accessors_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->accessors_count); ++j)
    {
        i = (int)(cgltf_parse_json_accessor(options, tokens, (int)(i), json_chunk, &out_data->accessors[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_materials(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_material)), (void**)(&out_data->materials), &out_data->materials_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->materials_count); ++j)
    {
        i = (int)(cgltf_parse_json_material(options, tokens, (int)(i), json_chunk, &out_data->materials[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_images(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_image)), (void**)(&out_data->images), &out_data->images_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->images_count); ++j)
    {
        i = (int)(cgltf_parse_json_image(options, tokens, (int)(i), json_chunk, &out_data->images[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_textures(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_texture)), (void**)(&out_data->textures), &out_data->textures_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->textures_count); ++j)
    {
        i = (int)(cgltf_parse_json_texture(options, tokens, (int)(i), json_chunk, &out_data->textures[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_samplers(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_sampler)), (void**)(&out_data->samplers), &out_data->samplers_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->samplers_count); ++j)
    {
        i = (int)(cgltf_parse_json_sampler(options, tokens, (int)(i), json_chunk, &out_data->samplers[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_meshopt_compression(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_meshopt_compression* out_meshopt_compression)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_buffer)) == (0))
        {
            ++i;
            out_meshopt_compression->buffer = (cgltf_buffer*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteOffset)) == (0))
        {
            ++i;
            out_meshopt_compression->offset = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteLength)) == (0))
        {
            ++i;
            out_meshopt_compression->size = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteStride)) == (0))
        {
            ++i;
            out_meshopt_compression->stride = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_count)) == (0))
        {
            ++i;
            out_meshopt_compression->count = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_mode)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_ATTRIBUTES)) == (0))
            {
                out_meshopt_compression->mode = (cgltf_meshopt_compression_mode)(cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_attributes);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_TRIANGLES)) == (0))
            {
                out_meshopt_compression->mode = (cgltf_meshopt_compression_mode)(cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_triangles);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_INDICES)) == (0))
            {
                out_meshopt_compression->mode = (cgltf_meshopt_compression_mode)(cgltf_meshopt_compression_mode.cgltf_meshopt_compression_mode_indices);
            }

            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_filter)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_NONE)) == (0))
            {
                out_meshopt_compression->filter = (cgltf_meshopt_compression_filter)(cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_none);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_OCTAHEDRAL)) == (0))
            {
                out_meshopt_compression->filter = (cgltf_meshopt_compression_filter)(cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_octahedral);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_QUATERNION)) == (0))
            {
                out_meshopt_compression->filter = (cgltf_meshopt_compression_filter)(cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_quaternion);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_EXPONENTIAL)) == (0))
            {
                out_meshopt_compression->filter = (cgltf_meshopt_compression_filter)(cgltf_meshopt_compression_filter.cgltf_meshopt_compression_filter_exponential);
            }

            ++i;
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_buffer_view(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_buffer_view* out_buffer_view)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_buffer_view->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_buffer)) == (0))
        {
            ++i;
            out_buffer_view->buffer = (cgltf_buffer*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteOffset)) == (0))
        {
            ++i;
            out_buffer_view->offset = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteLength)) == (0))
        {
            ++i;
            out_buffer_view->size = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteStride)) == (0))
        {
            ++i;
            out_buffer_view->stride = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_target)) == (0))
        {
            ++i;
            int type = (int)(cgltf_json_to_int(tokens + i, json_chunk));
            switch (type)
            {
                case 34962:
                    type = (int)(cgltf_buffer_view_type.cgltf_buffer_view_type_vertices);
                    break;
                case 34963:
                    type = (int)(cgltf_buffer_view_type.cgltf_buffer_view_type_indices);
                    break;
                default:
                    type = (int)(cgltf_buffer_view_type.cgltf_buffer_view_type_invalid);
                    break;
            }

            out_buffer_view->type = ((cgltf_buffer_view_type)(type));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_buffer_view->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_buffer_view->extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            out_buffer_view->extensions_count = (ulong)(0);
            out_buffer_view->extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            if (out_buffer_view->extensions == null)
            {
                return (int)(-2);
            }

            ++i;
            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_EXT_meshopt_compression)) == (0))
                {
                    out_buffer_view->has_meshopt_compression = (int)(1);
                    i = (int)(cgltf_parse_json_meshopt_compression(options, tokens, (int)(i + 1), json_chunk, &out_buffer_view->meshopt_compression));
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_buffer_view->extensions[out_buffer_view->extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_buffer_views(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_buffer_view)), (void**)(&out_data->buffer_views), &out_data->buffer_views_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->buffer_views_count); ++j)
    {
        i = (int)(cgltf_parse_json_buffer_view(options, tokens, (int)(i), json_chunk, &out_data->buffer_views[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_buffer(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_buffer* out_buffer)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_buffer->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_byteLength)) == (0))
        {
            ++i;
            out_buffer->size = (ulong)(cgltf_json_to_size(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_uri)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_buffer->uri));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_buffer->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_buffer->extensions_count, &out_buffer->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_buffers(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_buffer)), (void**)(&out_data->buffers), &out_data->buffers_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->buffers_count); ++j)
    {
        i = (int)(cgltf_parse_json_buffer(options, tokens, (int)(i), json_chunk, &out_data->buffers[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_skin(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_skin* out_skin)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_skin->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_joints)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_node)), (void**)(&out_skin->joints), &out_skin->joints_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_skin->joints_count); ++k)
            {
                out_skin->joints[k] = (cgltf_node*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                ++i;
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_skeleton)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
            {
                return (int)(-1);
            }

            out_skin->skeleton = (cgltf_node*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_inverseBindMatrices)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
            {
                return (int)(-1);
            }

            out_skin->inverse_bind_matrices = (cgltf_accessor*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_skin->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_skin->extensions_count, &out_skin->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_skins(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_skin)), (void**)(&out_data->skins), &out_data->skins_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->skins_count); ++j)
    {
        i = (int)(cgltf_parse_json_skin(options, tokens, (int)(i), json_chunk, &out_data->skins[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_camera(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_camera* out_camera)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_camera->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_perspective)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int data_size = (int)(tokens[i].size);
            ++i;
            if (out_camera->type != cgltf_camera_type.cgltf_camera_type_invalid)
            {
                return (int)(-1);
            }

            out_camera->type = (cgltf_camera_type)(cgltf_camera_type.cgltf_camera_type_perspective);
            for (int k = (int)(0); (k) < (data_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_aspectRatio)) == (0))
                {
                    ++i;
                    out_camera->data.perspective.has_aspect_ratio = (int)(1);
                    out_camera->data.perspective.aspect_ratio = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_yfov)) == (0))
                {
                    ++i;
                    out_camera->data.perspective.yfov = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_zfar)) == (0))
                {
                    ++i;
                    out_camera->data.perspective.has_zfar = (int)(1);
                    out_camera->data.perspective.zfar = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_znear)) == (0))
                {
                    ++i;
                    out_camera->data.perspective.znear = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
                {
                    i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_camera->data.perspective.extras));
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_orthographic)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int data_size = (int)(tokens[i].size);
            ++i;
            if (out_camera->type != cgltf_camera_type.cgltf_camera_type_invalid)
            {
                return (int)(-1);
            }

            out_camera->type = (cgltf_camera_type)(cgltf_camera_type.cgltf_camera_type_orthographic);
            for (int k = (int)(0); (k) < (data_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_xmag)) == (0))
                {
                    ++i;
                    out_camera->data.orthographic.xmag = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_ymag)) == (0))
                {
                    ++i;
                    out_camera->data.orthographic.ymag = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_zfar)) == (0))
                {
                    ++i;
                    out_camera->data.orthographic.zfar = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_znear)) == (0))
                {
                    ++i;
                    out_camera->data.orthographic.znear = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
                {
                    i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_camera->data.orthographic.extras));
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_camera->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_camera->extensions_count, &out_camera->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_cameras(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_camera)), (void**)(&out_data->cameras), &out_data->cameras_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->cameras_count); ++j)
    {
        i = (int)(cgltf_parse_json_camera(options, tokens, (int)(i), json_chunk, &out_data->cameras[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_light(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_light* out_light)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    out_light->color[0] = (float)(1.0f);
    out_light->color[1] = (float)(1.0f);
    out_light->color[2] = (float)(1.0f);
    out_light->intensity = (float)(1.0f);
    out_light->spot_inner_cone_angle = (float)(0.0f);
    out_light->spot_outer_cone_angle = (float)(3.1415926535f / 4.0f);
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_light->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_color)) == (0))
        {
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_light->color, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_intensity)) == (0))
        {
            ++i;
            out_light->intensity = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_type)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_directional)) == (0))
            {
                out_light->type = (cgltf_light_type)(cgltf_light_type.cgltf_light_type_directional);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_point)) == (0))
            {
                out_light->type = (cgltf_light_type)(cgltf_light_type.cgltf_light_type_point);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_spot)) == (0))
            {
                out_light->type = (cgltf_light_type)(cgltf_light_type.cgltf_light_type_spot);
            }

            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_range)) == (0))
        {
            ++i;
            out_light->range = (float)(cgltf_json_to_float(tokens + i, json_chunk));
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_spot)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int data_size = (int)(tokens[i].size);
            ++i;
            for (int k = (int)(0); (k) < (data_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_innerConeAngle)) == (0))
                {
                    ++i;
                    out_light->spot_inner_cone_angle = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_outerConeAngle)) == (0))
                {
                    ++i;
                    out_light->spot_outer_cone_angle = (float)(cgltf_json_to_float(tokens + i, json_chunk));
                    ++i;
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_light->extras));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_lights(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_light)), (void**)(&out_data->lights), &out_data->lights_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->lights_count); ++j)
    {
        i = (int)(cgltf_parse_json_light(options, tokens, (int)(i), json_chunk, &out_data->lights[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_node(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_node* out_node)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    out_node->rotation[3] = (float)(1.0f);
    out_node->scale[0] = (float)(1.0f);
    out_node->scale[1] = (float)(1.0f);
    out_node->scale[2] = (float)(1.0f);
    out_node->matrix[0] = (float)(1.0f);
    out_node->matrix[5] = (float)(1.0f);
    out_node->matrix[10] = (float)(1.0f);
    out_node->matrix[15] = (float)(1.0f);
    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_node->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_children)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_node)), (void**)(&out_node->children), &out_node->children_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_node->children_count); ++k)
            {
                out_node->children[k] = (cgltf_node*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                ++i;
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_mesh)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
            {
                return (int)(-1);
            }

            out_node->mesh = (cgltf_mesh*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_skin)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
            {
                return (int)(-1);
            }

            out_node->skin = (cgltf_skin*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_camera)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
            {
                return (int)(-1);
            }

            out_node->camera = (cgltf_camera*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_translation)) == (0))
        {
            out_node->has_translation = (int)(1);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_node->translation, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_rotation)) == (0))
        {
            out_node->has_rotation = (int)(1);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_node->rotation, (int)(4)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scale)) == (0))
        {
            out_node->has_scale = (int)(1);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_node->scale, (int)(3)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_matrix)) == (0))
        {
            out_node->has_matrix = (int)(1);
            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i + 1), json_chunk, out_node->matrix, (int)(16)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_weights)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(float)), (void**)(&out_node->weights), &out_node->weights_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            i = (int)(cgltf_parse_json_float_array(tokens, (int)(i - 1), json_chunk, out_node->weights, (int)(out_node->weights_count)));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_node->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_node->extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            out_node->extensions_count = (ulong)(0);
            out_node->extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            if (out_node->extensions == null)
            {
                return (int)(-2);
            }

            ++i;
            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_lights_punctual)) == (0))
                {
                    ++i;
                    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
                    {
                        return (int)(-1);
                    }

                    int data_size = (int)(tokens[i].size);
                    ++i;
                    for (int m = (int)(0); (m) < (data_size); ++m)
                    {
                        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                        {
                            return (int)(-1);
                        }

                        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_light)) == (0))
                        {
                            ++i;
                            if ((tokens[i]).type != (jsmntype_t.JSMN_PRIMITIVE))
                            {
                                return (int)(-1);
                            }

                            out_node->light = (cgltf_light*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                            ++i;
                        }
                        else
                        {
                            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                        }

                        if ((i) < (0))
                        {
                            return (int)(i);
                        }
                    }
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_EXT_mesh_gpu_instancing)) == (0))
                {
                    out_node->has_mesh_gpu_instancing = (int)(1);
                    i = (int)(cgltf_parse_json_mesh_gpu_instancing(options, tokens, (int)(i + 1), json_chunk, &out_node->mesh_gpu_instancing));
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_node->extensions[out_node->extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_nodes(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_node)), (void**)(&out_data->nodes), &out_data->nodes_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->nodes_count); ++j)
    {
        i = (int)(cgltf_parse_json_node(options, tokens, (int)(i), json_chunk, &out_data->nodes[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_scene(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_scene* out_scene)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_scene->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_nodes)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_node)), (void**)(&out_scene->nodes), &out_scene->nodes_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_scene->nodes_count); ++k)
            {
                out_scene->nodes[k] = (cgltf_node*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                ++i;
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_scene->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_scene->extensions_count, &out_scene->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_scenes(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_scene)), (void**)(&out_data->scenes), &out_data->scenes_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->scenes_count); ++j)
    {
        i = (int)(cgltf_parse_json_scene(options, tokens, (int)(i), json_chunk, &out_data->scenes[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_animation_sampler(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_animation_sampler* out_sampler)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_input)) == (0))
        {
            ++i;
            out_sampler->input = (cgltf_accessor*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_output)) == (0))
        {
            ++i;
            out_sampler->output = (cgltf_accessor*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_interpolation)) == (0))
        {
            ++i;
            if ((cgltf_json_strcmp(tokens + i, json_chunk, const_LINEAR)) == (0))
            {
                out_sampler->interpolation = (cgltf_interpolation_type)(cgltf_interpolation_type.cgltf_interpolation_type_linear);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_STEP)) == (0))
            {
                out_sampler->interpolation = (cgltf_interpolation_type)(cgltf_interpolation_type.cgltf_interpolation_type_step);
            }
            else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_CUBICSPLINE)) == (0))
            {
                out_sampler->interpolation = (cgltf_interpolation_type)(cgltf_interpolation_type.cgltf_interpolation_type_cubic_spline);
            }

            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_sampler->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_sampler->extensions_count, &out_sampler->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_animation_channel(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_animation_channel* out_channel)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_sampler)) == (0))
        {
            ++i;
            out_channel->sampler = (cgltf_animation_sampler*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_target)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            int target_size = (int)(tokens[i].size);
            ++i;
            for (int k = (int)(0); (k) < (target_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_node)) == (0))
                {
                    ++i;
                    out_channel->target_node = (cgltf_node*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_path)) == (0))
                {
                    ++i;
                    if ((cgltf_json_strcmp(tokens + i, json_chunk, const_translation)) == (0))
                    {
                        out_channel->target_path = (cgltf_animation_path_type)(cgltf_animation_path_type.cgltf_animation_path_type_translation);
                    }
                    else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_rotation)) == (0))
                    {
                        out_channel->target_path = (cgltf_animation_path_type)(cgltf_animation_path_type.cgltf_animation_path_type_rotation);
                    }
                    else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scale)) == (0))
                    {
                        out_channel->target_path = (cgltf_animation_path_type)(cgltf_animation_path_type.cgltf_animation_path_type_scale);
                    }
                    else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_weights)) == (0))
                    {
                        out_channel->target_path = (cgltf_animation_path_type)(cgltf_animation_path_type.cgltf_animation_path_type_weights);
                    }

                    ++i;
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
                {
                    i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_channel->extras));
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
                {
                    i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_channel->extensions_count, &out_channel->extensions));
                }
                else
                {
                    i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_animation(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_animation* out_animation)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_animation->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_samplers)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_animation_sampler)), (void**)(&out_animation->samplers), &out_animation->samplers_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_animation->samplers_count); ++k)
            {
                i = (int)(cgltf_parse_json_animation_sampler(options, tokens, (int)(i), json_chunk, &out_animation->samplers[k]));
                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_channels)) == (0))
        {
            i = (int)(cgltf_parse_json_array(options, tokens, (int)(i + 1), json_chunk, (ulong)(sizeof(cgltf_animation_channel)), (void**)(&out_animation->channels), &out_animation->channels_count));
            if ((i) < (0))
            {
                return (int)(i);
            }

            for (ulong k = (ulong)(0); (k) < (out_animation->channels_count); ++k)
            {
                i = (int)(cgltf_parse_json_animation_channel(options, tokens, (int)(i), json_chunk, &out_animation->channels[k]));
                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_animation->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_animation->extensions_count, &out_animation->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_animations(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_animation)), (void**)(&out_data->animations), &out_data->animations_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->animations_count); ++j)
    {
        i = (int)(cgltf_parse_json_animation(options, tokens, (int)(i), json_chunk, &out_data->animations[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_variant(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_material_variant* out_variant)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_name)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_variant->name));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_variant->extras));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_variants(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    i = (int)(cgltf_parse_json_array(options, tokens, (int)(i), json_chunk, (ulong)(sizeof(cgltf_material_variant)), (void**)(&out_data->variants), &out_data->variants_count));
    if ((i) < (0))
    {
        return (int)(i);
    }

    for (ulong j = (ulong)(0); (j) < (out_data->variants_count); ++j)
    {
        i = (int)(cgltf_parse_json_variant(options, tokens, (int)(i), json_chunk, &out_data->variants[j]));
        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static int cgltf_parse_json_asset(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_asset* out_asset)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_copyright)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_asset->copyright));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_generator)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_asset->generator));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_version)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_asset->version));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_minVersion)) == (0))
        {
            i = (int)(cgltf_parse_json_string(options, tokens, (int)(i + 1), json_chunk, &out_asset->min_version));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_asset->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            i = (int)(cgltf_parse_json_unprocessed_extensions(options, tokens, (int)(i), json_chunk, &out_asset->extensions_count, &out_asset->extensions));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    if (((out_asset->version) != null) && ((CRuntime.atof(out_asset->version)) < (2)))
    {
        return (int)(-3);
    }

    return (int)(i);
}
public static int cgltf_fixup_pointers(cgltf_data* data)
{
    for (ulong i = (ulong)(0); (i) < (data->meshes_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->meshes[i].primitives_count); ++j)
        {
            if ((data->meshes[i].primitives[j].indices) != null)
            {
                if (((ulong)(data->meshes[i].primitives[j].indices)) > (data->accessors_count))
                {
                    return (int)(-1);
                }

                data->meshes[i].primitives[j].indices = &data->accessors[(ulong)(data->meshes[i].primitives[j].indices) - 1];
            }

            if ((data->meshes[i].primitives[j].material) != null)
            {
                if (((ulong)(data->meshes[i].primitives[j].material)) > (data->materials_count))
                {
                    return (int)(-1);
                }

                data->meshes[i].primitives[j].material = &data->materials[(ulong)(data->meshes[i].primitives[j].material) - 1];
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].attributes_count); ++k)
            {
                if ((data->meshes[i].primitives[j].attributes[k].data == null) || (((ulong)(data->meshes[i].primitives[j].attributes[k].data)) > (data->accessors_count)))
                {
                    return (int)(-1);
                }

                data->meshes[i].primitives[j].attributes[k].data = &data->accessors[(ulong)(data->meshes[i].primitives[j].attributes[k].data) - 1];
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].targets_count); ++k)
            {
                for (ulong m = (ulong)(0); (m) < (data->meshes[i].primitives[j].targets[k].attributes_count); ++m)
                {
                    if ((data->meshes[i].primitives[j].targets[k].attributes[m].data == null) || (((ulong)(data->meshes[i].primitives[j].targets[k].attributes[m].data)) > (data->accessors_count)))
                    {
                        return (int)(-1);
                    }

                    data->meshes[i].primitives[j].targets[k].attributes[m].data = &data->accessors[(ulong)(data->meshes[i].primitives[j].targets[k].attributes[m].data) - 1];
                }
            }

            if ((data->meshes[i].primitives[j].has_draco_mesh_compression) != 0)
            {
                if ((data->meshes[i].primitives[j].draco_mesh_compression.buffer_view == null) || (((ulong)(data->meshes[i].primitives[j].draco_mesh_compression.buffer_view)) > (data->buffer_views_count)))
                {
                    return (int)(-1);
                }

                data->meshes[i].primitives[j].draco_mesh_compression.buffer_view = &data->buffer_views[(ulong)(data->meshes[i].primitives[j].draco_mesh_compression.buffer_view) - 1];
                for (ulong m = (ulong)(0); (m) < (data->meshes[i].primitives[j].draco_mesh_compression.attributes_count); ++m)
                {
                    if ((data->meshes[i].primitives[j].draco_mesh_compression.attributes[m].data == null) || (((ulong)(data->meshes[i].primitives[j].draco_mesh_compression.attributes[m].data)) > (data->accessors_count)))
                    {
                        return (int)(-1);
                    }

                    data->meshes[i].primitives[j].draco_mesh_compression.attributes[m].data = &data->accessors[(ulong)(data->meshes[i].primitives[j].draco_mesh_compression.attributes[m].data) - 1];
                }
            }

            for (ulong k = (ulong)(0); (k) < (data->meshes[i].primitives[j].mappings_count); ++k)
            {
                if ((data->meshes[i].primitives[j].mappings[k].material == null) || (((ulong)(data->meshes[i].primitives[j].mappings[k].material)) > (data->materials_count)))
                {
                    return (int)(-1);
                }

                data->meshes[i].primitives[j].mappings[k].material = &data->materials[(ulong)(data->meshes[i].primitives[j].mappings[k].material) - 1];
            }
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->accessors_count); ++i)
    {
        if ((data->accessors[i].buffer_view) != null)
        {
            if (((ulong)(data->accessors[i].buffer_view)) > (data->buffer_views_count))
            {
                return (int)(-1);
            }

            data->accessors[i].buffer_view = &data->buffer_views[(ulong)(data->accessors[i].buffer_view) - 1];
        }

        if ((data->accessors[i].is_sparse) != 0)
        {
            if ((data->accessors[i].sparse.indices_buffer_view == null) || (((ulong)(data->accessors[i].sparse.indices_buffer_view)) > (data->buffer_views_count)))
            {
                return (int)(-1);
            }

            data->accessors[i].sparse.indices_buffer_view = &data->buffer_views[(ulong)(data->accessors[i].sparse.indices_buffer_view) - 1];
            if ((data->accessors[i].sparse.values_buffer_view == null) || (((ulong)(data->accessors[i].sparse.values_buffer_view)) > (data->buffer_views_count)))
            {
                return (int)(-1);
            }

            data->accessors[i].sparse.values_buffer_view = &data->buffer_views[(ulong)(data->accessors[i].sparse.values_buffer_view) - 1];
        }

        if ((data->accessors[i].buffer_view) != null)
        {
            data->accessors[i].stride = (ulong)(data->accessors[i].buffer_view->stride);
        }

        if ((data->accessors[i].stride) == (0))
        {
            data->accessors[i].stride = (ulong)(cgltf_calc_size((cgltf_type)(data->accessors[i].type), (cgltf_component_type)(data->accessors[i].component_type)));
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->textures_count); ++i)
    {
        if ((data->textures[i].image) != null)
        {
            if (((ulong)(data->textures[i].image)) > (data->images_count))
            {
                return (int)(-1);
            }

            data->textures[i].image = &data->images[(ulong)(data->textures[i].image) - 1];
        }

        if ((data->textures[i].basisu_image) != null)
        {
            if (((ulong)(data->textures[i].basisu_image)) > (data->images_count))
            {
                return (int)(-1);
            }

            data->textures[i].basisu_image = &data->images[(ulong)(data->textures[i].basisu_image) - 1];
        }

        if ((data->textures[i].webp_image) != null)
        {
            if (((ulong)(data->textures[i].webp_image)) > (data->images_count))
            {
                return (int)(-1);
            }

            data->textures[i].webp_image = &data->images[(ulong)(data->textures[i].webp_image) - 1];
        }

        if ((data->textures[i].sampler) != null)
        {
            if (((ulong)(data->textures[i].sampler)) > (data->samplers_count))
            {
                return (int)(-1);
            }

            data->textures[i].sampler = &data->samplers[(ulong)(data->textures[i].sampler) - 1];
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->images_count); ++i)
    {
        if ((data->images[i].buffer_view) != null)
        {
            if (((ulong)(data->images[i].buffer_view)) > (data->buffer_views_count))
            {
                return (int)(-1);
            }

            data->images[i].buffer_view = &data->buffer_views[(ulong)(data->images[i].buffer_view) - 1];
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->materials_count); ++i)
    {
        if ((data->materials[i].normal_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].normal_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].normal_texture.texture = &data->textures[(ulong)(data->materials[i].normal_texture.texture) - 1];
        }

        if ((data->materials[i].emissive_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].emissive_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].emissive_texture.texture = &data->textures[(ulong)(data->materials[i].emissive_texture.texture) - 1];
        }

        if ((data->materials[i].occlusion_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].occlusion_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].occlusion_texture.texture = &data->textures[(ulong)(data->materials[i].occlusion_texture.texture) - 1];
        }

        if ((data->materials[i].pbr_metallic_roughness.base_color_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].pbr_metallic_roughness.base_color_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].pbr_metallic_roughness.base_color_texture.texture = &data->textures[(ulong)(data->materials[i].pbr_metallic_roughness.base_color_texture.texture) - 1];
        }

        if ((data->materials[i].pbr_metallic_roughness.metallic_roughness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].pbr_metallic_roughness.metallic_roughness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].pbr_metallic_roughness.metallic_roughness_texture.texture = &data->textures[(ulong)(data->materials[i].pbr_metallic_roughness.metallic_roughness_texture.texture) - 1];
        }

        if ((data->materials[i].pbr_specular_glossiness.diffuse_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].pbr_specular_glossiness.diffuse_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].pbr_specular_glossiness.diffuse_texture.texture = &data->textures[(ulong)(data->materials[i].pbr_specular_glossiness.diffuse_texture.texture) - 1];
        }

        if ((data->materials[i].pbr_specular_glossiness.specular_glossiness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].pbr_specular_glossiness.specular_glossiness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].pbr_specular_glossiness.specular_glossiness_texture.texture = &data->textures[(ulong)(data->materials[i].pbr_specular_glossiness.specular_glossiness_texture.texture) - 1];
        }

        if ((data->materials[i].clearcoat.clearcoat_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].clearcoat.clearcoat_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].clearcoat.clearcoat_texture.texture = &data->textures[(ulong)(data->materials[i].clearcoat.clearcoat_texture.texture) - 1];
        }

        if ((data->materials[i].clearcoat.clearcoat_roughness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].clearcoat.clearcoat_roughness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].clearcoat.clearcoat_roughness_texture.texture = &data->textures[(ulong)(data->materials[i].clearcoat.clearcoat_roughness_texture.texture) - 1];
        }

        if ((data->materials[i].clearcoat.clearcoat_normal_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].clearcoat.clearcoat_normal_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].clearcoat.clearcoat_normal_texture.texture = &data->textures[(ulong)(data->materials[i].clearcoat.clearcoat_normal_texture.texture) - 1];
        }

        if ((data->materials[i].specular.specular_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].specular.specular_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].specular.specular_texture.texture = &data->textures[(ulong)(data->materials[i].specular.specular_texture.texture) - 1];
        }

        if ((data->materials[i].specular.specular_color_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].specular.specular_color_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].specular.specular_color_texture.texture = &data->textures[(ulong)(data->materials[i].specular.specular_color_texture.texture) - 1];
        }

        if ((data->materials[i].transmission.transmission_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].transmission.transmission_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].transmission.transmission_texture.texture = &data->textures[(ulong)(data->materials[i].transmission.transmission_texture.texture) - 1];
        }

        if ((data->materials[i].volume.thickness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].volume.thickness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].volume.thickness_texture.texture = &data->textures[(ulong)(data->materials[i].volume.thickness_texture.texture) - 1];
        }

        if ((data->materials[i].sheen.sheen_color_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].sheen.sheen_color_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].sheen.sheen_color_texture.texture = &data->textures[(ulong)(data->materials[i].sheen.sheen_color_texture.texture) - 1];
        }

        if ((data->materials[i].sheen.sheen_roughness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].sheen.sheen_roughness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].sheen.sheen_roughness_texture.texture = &data->textures[(ulong)(data->materials[i].sheen.sheen_roughness_texture.texture) - 1];
        }

        if ((data->materials[i].iridescence.iridescence_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].iridescence.iridescence_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].iridescence.iridescence_texture.texture = &data->textures[(ulong)(data->materials[i].iridescence.iridescence_texture.texture) - 1];
        }

        if ((data->materials[i].iridescence.iridescence_thickness_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].iridescence.iridescence_thickness_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].iridescence.iridescence_thickness_texture.texture = &data->textures[(ulong)(data->materials[i].iridescence.iridescence_thickness_texture.texture) - 1];
        }

        if ((data->materials[i].diffuse_transmission.diffuse_transmission_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].diffuse_transmission.diffuse_transmission_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].diffuse_transmission.diffuse_transmission_texture.texture = &data->textures[(ulong)(data->materials[i].diffuse_transmission.diffuse_transmission_texture.texture) - 1];
        }

        if ((data->materials[i].diffuse_transmission.diffuse_transmission_color_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].diffuse_transmission.diffuse_transmission_color_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].diffuse_transmission.diffuse_transmission_color_texture.texture = &data->textures[(ulong)(data->materials[i].diffuse_transmission.diffuse_transmission_color_texture.texture) - 1];
        }

        if ((data->materials[i].anisotropy.anisotropy_texture.texture) != null)
        {
            if (((ulong)(data->materials[i].anisotropy.anisotropy_texture.texture)) > (data->textures_count))
            {
                return (int)(-1);
            }

            data->materials[i].anisotropy.anisotropy_texture.texture = &data->textures[(ulong)(data->materials[i].anisotropy.anisotropy_texture.texture) - 1];
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->buffer_views_count); ++i)
    {
        if ((data->buffer_views[i].buffer == null) || (((ulong)(data->buffer_views[i].buffer)) > (data->buffers_count)))
        {
            return (int)(-1);
        }

        data->buffer_views[i].buffer = &data->buffers[(ulong)(data->buffer_views[i].buffer) - 1];
        if ((data->buffer_views[i].has_meshopt_compression) != 0)
        {
            if ((data->buffer_views[i].meshopt_compression.buffer == null) || (((ulong)(data->buffer_views[i].meshopt_compression.buffer)) > (data->buffers_count)))
            {
                return (int)(-1);
            }

            data->buffer_views[i].meshopt_compression.buffer = &data->buffers[(ulong)(data->buffer_views[i].meshopt_compression.buffer) - 1];
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->skins_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->skins[i].joints_count); ++j)
        {
            if ((data->skins[i].joints[j] == null) || (((ulong)(data->skins[i].joints[j])) > (data->nodes_count)))
            {
                return (int)(-1);
            }

            data->skins[i].joints[j] = &data->nodes[(ulong)(data->skins[i].joints[j]) - 1];
        }

        if ((data->skins[i].skeleton) != null)
        {
            if (((ulong)(data->skins[i].skeleton)) > (data->nodes_count))
            {
                return (int)(-1);
            }

            data->skins[i].skeleton = &data->nodes[(ulong)(data->skins[i].skeleton) - 1];
        }

        if ((data->skins[i].inverse_bind_matrices) != null)
        {
            if (((ulong)(data->skins[i].inverse_bind_matrices)) > (data->accessors_count))
            {
                return (int)(-1);
            }

            data->skins[i].inverse_bind_matrices = &data->accessors[(ulong)(data->skins[i].inverse_bind_matrices) - 1];
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->nodes_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->nodes[i].children_count); ++j)
        {
            if ((data->nodes[i].children[j] == null) || (((ulong)(data->nodes[i].children[j])) > (data->nodes_count)))
            {
                return (int)(-1);
            }

            data->nodes[i].children[j] = &data->nodes[(ulong)(data->nodes[i].children[j]) - 1];
            if ((data->nodes[i].children[j]->parent) != null)
            {
                return (int)(-1);
            }

            data->nodes[i].children[j]->parent = &data->nodes[i];
        }

        if ((data->nodes[i].mesh) != null)
        {
            if (((ulong)(data->nodes[i].mesh)) > (data->meshes_count))
            {
                return (int)(-1);
            }

            data->nodes[i].mesh = &data->meshes[(ulong)(data->nodes[i].mesh) - 1];
        }

        if ((data->nodes[i].skin) != null)
        {
            if (((ulong)(data->nodes[i].skin)) > (data->skins_count))
            {
                return (int)(-1);
            }

            data->nodes[i].skin = &data->skins[(ulong)(data->nodes[i].skin) - 1];
        }

        if ((data->nodes[i].camera) != null)
        {
            if (((ulong)(data->nodes[i].camera)) > (data->cameras_count))
            {
                return (int)(-1);
            }

            data->nodes[i].camera = &data->cameras[(ulong)(data->nodes[i].camera) - 1];
        }

        if ((data->nodes[i].light) != null)
        {
            if (((ulong)(data->nodes[i].light)) > (data->lights_count))
            {
                return (int)(-1);
            }

            data->nodes[i].light = &data->lights[(ulong)(data->nodes[i].light) - 1];
        }

        if ((data->nodes[i].has_mesh_gpu_instancing) != 0)
        {
            for (ulong m = (ulong)(0); (m) < (data->nodes[i].mesh_gpu_instancing.attributes_count); ++m)
            {
                if ((data->nodes[i].mesh_gpu_instancing.attributes[m].data == null) || (((ulong)(data->nodes[i].mesh_gpu_instancing.attributes[m].data)) > (data->accessors_count)))
                {
                    return (int)(-1);
                }

                data->nodes[i].mesh_gpu_instancing.attributes[m].data = &data->accessors[(ulong)(data->nodes[i].mesh_gpu_instancing.attributes[m].data) - 1];
            }
        }
    }

    for (ulong i = (ulong)(0); (i) < (data->scenes_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->scenes[i].nodes_count); ++j)
        {
            if ((data->scenes[i].nodes[j] == null) || (((ulong)(data->scenes[i].nodes[j])) > (data->nodes_count)))
            {
                return (int)(-1);
            }

            data->scenes[i].nodes[j] = &data->nodes[(ulong)(data->scenes[i].nodes[j]) - 1];
            if ((data->scenes[i].nodes[j]->parent) != null)
            {
                return (int)(-1);
            }
        }
    }

    if ((data->scene) != null)
    {
        if (((ulong)(data->scene)) > (data->scenes_count))
        {
            return (int)(-1);
        }

        data->scene = &data->scenes[(ulong)(data->scene) - 1];
    }

    for (ulong i = (ulong)(0); (i) < (data->animations_count); ++i)
    {
        for (ulong j = (ulong)(0); (j) < (data->animations[i].samplers_count); ++j)
        {
            if ((data->animations[i].samplers[j].input == null) || (((ulong)(data->animations[i].samplers[j].input)) > (data->accessors_count)))
            {
                return (int)(-1);
            }

            data->animations[i].samplers[j].input = &data->accessors[(ulong)(data->animations[i].samplers[j].input) - 1];
            if ((data->animations[i].samplers[j].output == null) || (((ulong)(data->animations[i].samplers[j].output)) > (data->accessors_count)))
            {
                return (int)(-1);
            }

            data->animations[i].samplers[j].output = &data->accessors[(ulong)(data->animations[i].samplers[j].output) - 1];
        }

        for (ulong j = (ulong)(0); (j) < (data->animations[i].channels_count); ++j)
        {
            if ((data->animations[i].channels[j].sampler == null) || (((ulong)(data->animations[i].channels[j].sampler)) > (data->animations[i].samplers_count)))
            {
                return (int)(-1);
            }

            data->animations[i].channels[j].sampler = &data->animations[i].samplers[(ulong)(data->animations[i].channels[j].sampler) - 1];
            if ((data->animations[i].channels[j].target_node) != null)
            {
                if (((ulong)(data->animations[i].channels[j].target_node)) > (data->nodes_count))
                {
                    return (int)(-1);
                }

                data->animations[i].channels[j].target_node = &data->nodes[(ulong)(data->animations[i].channels[j].target_node) - 1];
            }
        }
    }

    return (int)(0);
}
public static int cgltf_parse_json_root(cgltf_options* options, jsmntok_t* tokens, int i, byte* json_chunk, cgltf_data* out_data)
{
    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
    {
        return (int)(-1);
    }

    int size = (int)(tokens[i].size);
    ++i;
    for (int j = (int)(0); (j) < (size); ++j)
    {
        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
        {
            return (int)(-1);
        }

        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_asset)) == (0))
        {
            i = (int)(cgltf_parse_json_asset(options, tokens, (int)(i + 1), json_chunk, &out_data->asset));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_meshes)) == (0))
        {
            i = (int)(cgltf_parse_json_meshes(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_accessors)) == (0))
        {
            i = (int)(cgltf_parse_json_accessors(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_bufferViews)) == (0))
        {
            i = (int)(cgltf_parse_json_buffer_views(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_buffers)) == (0))
        {
            i = (int)(cgltf_parse_json_buffers(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_materials)) == (0))
        {
            i = (int)(cgltf_parse_json_materials(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_images)) == (0))
        {
            i = (int)(cgltf_parse_json_images(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_textures)) == (0))
        {
            i = (int)(cgltf_parse_json_textures(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_samplers)) == (0))
        {
            i = (int)(cgltf_parse_json_samplers(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_skins)) == (0))
        {
            i = (int)(cgltf_parse_json_skins(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_cameras)) == (0))
        {
            i = (int)(cgltf_parse_json_cameras(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_nodes)) == (0))
        {
            i = (int)(cgltf_parse_json_nodes(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scenes)) == (0))
        {
            i = (int)(cgltf_parse_json_scenes(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_scene)) == (0))
        {
            ++i;
            out_data->scene = (cgltf_scene*)((ulong)(cgltf_json_to_int(tokens + i, json_chunk)) + 1);
            ++i;
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_animations)) == (0))
        {
            i = (int)(cgltf_parse_json_animations(options, tokens, (int)(i + 1), json_chunk, out_data));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extras)) == (0))
        {
            i = (int)(cgltf_parse_json_extras(options, tokens, (int)(i + 1), json_chunk, &out_data->extras));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensions)) == (0))
        {
            ++i;
            if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
            {
                return (int)(-1);
            }

            if ((out_data->data_extensions) != null)
            {
                return (int)(-1);
            }

            int extensions_size = (int)(tokens[i].size);
            out_data->data_extensions_count = (ulong)(0);
            out_data->data_extensions = (cgltf_extension*)(cgltf_calloc(options, (ulong)(sizeof(cgltf_extension)), (ulong)(extensions_size)));
            if (out_data->data_extensions == null)
            {
                return (int)(-2);
            }

            ++i;
            for (int k = (int)(0); (k) < (extensions_size); ++k)
            {
                if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                {
                    return (int)(-1);
                }

                if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_lights_punctual)) == (0))
                {
                    ++i;
                    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
                    {
                        return (int)(-1);
                    }

                    int data_size = (int)(tokens[i].size);
                    ++i;
                    for (int m = (int)(0); (m) < (data_size); ++m)
                    {
                        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                        {
                            return (int)(-1);
                        }

                        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_lights)) == (0))
                        {
                            i = (int)(cgltf_parse_json_lights(options, tokens, (int)(i + 1), json_chunk, out_data));
                        }
                        else
                        {
                            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                        }

                        if ((i) < (0))
                        {
                            return (int)(i);
                        }
                    }
                }
                else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_KHR_materials_variants)) == (0))
                {
                    ++i;
                    if ((tokens[i]).type != (jsmntype_t.JSMN_OBJECT))
                    {
                        return (int)(-1);
                    }

                    int data_size = (int)(tokens[i].size);
                    ++i;
                    for (int m = (int)(0); (m) < (data_size); ++m)
                    {
                        if (((tokens[i]).type != jsmntype_t.JSMN_STRING) || (((tokens[i]).size) == (0)))
                        {
                            return (int)(-1);
                        }

                        if ((cgltf_json_strcmp(tokens + i, json_chunk, const_variants)) == (0))
                        {
                            i = (int)(cgltf_parse_json_variants(options, tokens, (int)(i + 1), json_chunk, out_data));
                        }
                        else
                        {
                            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
                        }

                        if ((i) < (0))
                        {
                            return (int)(i);
                        }
                    }
                }
                else
                {
                    i = (int)(cgltf_parse_json_unprocessed_extension(options, tokens, (int)(i), json_chunk, &(out_data->data_extensions[out_data->data_extensions_count++])));
                }

                if ((i) < (0))
                {
                    return (int)(i);
                }
            }
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensionsUsed)) == (0))
        {
            i = (int)(cgltf_parse_json_string_array(options, tokens, (int)(i + 1), json_chunk, &out_data->extensions_used, &out_data->extensions_used_count));
        }
        else if ((cgltf_json_strcmp(tokens + i, json_chunk, const_extensionsRequired)) == (0))
        {
            i = (int)(cgltf_parse_json_string_array(options, tokens, (int)(i + 1), json_chunk, &out_data->extensions_required, &out_data->extensions_required_count));
        }
        else
        {
            i = (int)(cgltf_skip_json(tokens, (int)(i + 1)));
        }

        if ((i) < (0))
        {
            return (int)(i);
        }
    }

    return (int)(i);
}
public static jsmntok_t* jsmn_alloc_token(jsmn_parser* parser, jsmntok_t* tokens, ulong num_tokens)
{
    jsmntok_t* tok;
    if ((parser->toknext) >= (num_tokens))
    {
        return null;
    }

    tok = &tokens[parser->toknext++];
    tok->start = (long)(tok->end = (long)(-1));
    tok->size = (int)(0);
    tok->parent = (int)(-1);
    return tok;
}
public static void jsmn_fill_token(jsmntok_t* token, jsmntype_t type, long start, long end)
{
    token->type = (jsmntype_t)(type);
    token->start = (long)(start);
    token->end = (long)(end);
    token->size = (int)(0);
}
public static int jsmn_parse_primitive(jsmn_parser* parser, sbyte* js, ulong len, jsmntok_t* tokens, ulong num_tokens)
{
    jsmntok_t* token;
    long start = 0;
    start = (long)(parser->pos);
    for (; ((parser->pos) < (len)) && (js[parser->pos] != 0); parser->pos++)
    {
        switch (js[parser->pos])
        {
            case 9:
            case 13:
            case 10:
            case 32:
            case 44:
            case 93:
            case 125:
                goto found;
        }

        if (((js[parser->pos]) < (32)) || ((js[parser->pos]) >= (127)))
        {
            parser->pos = (ulong)(start);
            return (int)(jsmnerr.JSMN_ERROR_INVAL);
        }
    }

    parser->pos = (ulong)(start);
    return (int)(jsmnerr.JSMN_ERROR_PART);
    found:
        ; if  ( ( tokens ) == ( null ) ) { parser -> pos -- ;  return  ( int ) ( 0 ) ;  }
    token = jsmn_alloc_token(parser, tokens, (ulong)(num_tokens));
    if ((token) == (null))
    {
        parser->pos = (ulong)(start);
        return (int)(jsmnerr.JSMN_ERROR_NOMEM);
    }

    jsmn_fill_token(token, (jsmntype_t)(jsmntype_t.JSMN_PRIMITIVE), (long)(start), (long)(parser->pos));
    token->parent = (int)(parser->toksuper);
    parser->pos--;
    return (int)(0);
}
public static int jsmn_parse_string(jsmn_parser* parser, sbyte* js, ulong len, jsmntok_t* tokens, ulong num_tokens)
{
    jsmntok_t* token;
    long start = (long)(parser->pos);
    parser->pos++;
    for (; ((parser->pos) < (len)) && (js[parser->pos] != 0); parser->pos++)
    {
        sbyte c = (sbyte)(js[parser->pos]);
        if ((c) == (34))
        {
            if ((tokens) == (null))
            {
                return (int)(0);
            }

            token = jsmn_alloc_token(parser, tokens, (ulong)(num_tokens));
            if ((token) == (null))
            {
                parser->pos = (ulong)(start);
                return (int)(jsmnerr.JSMN_ERROR_NOMEM);
            }

            jsmn_fill_token(token, (jsmntype_t)(jsmntype_t.JSMN_STRING), (long)(start + 1), (long)(parser->pos));
            token->parent = (int)(parser->toksuper);
            return (int)(0);
        }

        if (((c) == (92)) && ((parser->pos + 1) < (len)))
        {
            int i = 0;
            parser->pos++;
            switch (js[parser->pos])
            {
                case 34:
                case 47:
                case 92:
                case 98:
                case 102:
                case 114:
                case 110:
                case 116:
                    break;
                case 117:
                    parser->pos++;
                    for (i = (int)(0); (((i) < (4)) && ((parser->pos) < (len))) && (js[parser->pos] != 0); i++)
                    {
                        if (!(((((js[parser->pos]) >= (48)) && ((js[parser->pos]) <= (57))) || (((js[parser->pos]) >= (65)) && ((js[parser->pos]) <= (70)))) || (((js[parser->pos]) >= (97)) && ((js[parser->pos]) <= (102)))))
                        {
                            parser->pos = (ulong)(start);
                            return (int)(jsmnerr.JSMN_ERROR_INVAL);
                        }

                        parser->pos++;
                    }

                    parser->pos--;
                    break;
                default:
                    parser->pos = (ulong)(start);
                    return (int)(jsmnerr.JSMN_ERROR_INVAL);
            }
        }
    }

    parser->pos = (ulong)(start);
    return (int)(jsmnerr.JSMN_ERROR_PART);
}

public static cgltf_result cgltf_default_file_read(cgltf_memory_options* memory_options, cgltf_file_options* file_options, sbyte* path, ulong* size, void** data)
{
        delegate0 memory_alloc = memory_options->alloc_func != IntPtr.Zero ? memory_options->GetAllocFunc() : cgltf_default_alloc;
        delegate1 memory_free = memory_options->free_func != IntPtr.Zero ? memory_options->GetFreeFunc() : cgltf_default_free;

        // 使用 Encoding.UTF8 解码字节数组
        string pathStr = System.Text.Encoding.UTF8.GetString((byte*)path, (int)CRuntime.strlen(path));

        if (!System.IO.File.Exists(pathStr))
        {
            return (cgltf_result)(cgltf_result.cgltf_result_file_not_found);
        }

        ulong file_size = (ulong)((size) != null ? *size : 0);
        if ((file_size) == (0))
        {
            long length = 0;
            var info = new System.IO.FileInfo(pathStr);
            length = info.Length;
            if ((length) < (0))
            {
                return (cgltf_result)(cgltf_result.cgltf_result_io_error);
            }

            file_size = ((ulong)(length));
        }

        sbyte* file_data = (sbyte*)(memory_alloc(memory_options->user_data, (ulong)(file_size)));
        var span = new Span<byte>(file_data, (int)file_size);
        if (file_data == null)
        {
            return (cgltf_result)(cgltf_result.cgltf_result_out_of_memory);
        }

        var fs = new System.IO.FileStream(pathStr, System.IO.FileMode.Open, System.IO.FileAccess.Read);
        var read_size = fs.Read(span);
        fs.Close();

        if ((ulong)read_size != file_size)
        {
            memory_free(memory_options->user_data, file_data);
            return (cgltf_result)(cgltf_result.cgltf_result_io_error);
        }

        if ((size) != null)
        {
            *size = (ulong)(file_size);
        }

        if ((data) != null)
        {
            *data = file_data;
        }

        return (cgltf_result)(cgltf_result.cgltf_result_success);
}const int SIZE_MAX = 65535;
}